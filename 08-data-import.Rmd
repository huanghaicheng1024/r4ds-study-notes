# Data import

## 简介

学习利用`readr`包将纯文本格式的矩形文件读入 R。
```{r}
library(tidyverse)
```

## 入门

`readr`有很多函数提供类似的使用方法实现对不同格式平面文件的读入，下面以`read_csv`函数为例学习这些函数一般的用法。

`read_csv`常用参数：
<div align=center>![](08-data-import_files/readcsv.png){width=70%}</div>


## 解析向量

我们先学习`parse_*()`函数族，它们接收一个字符串，然后返回一个特定数据类型的向量。

各函数的用法大致一样，第一个参数是需要解析的字符向量，`na`参数设定了哪些字符串应该当作缺失值来处理。解析失败的值在输出中是以**缺失值**的形式存在的。

各函数的作用大致如下：

<div align=center>![](08-data-import_files/parse.png){width=80%}</div>


## 解析文件

### 策略

`readr`使用一种启发式过程来确定每列的类型：先读取文件的前1000行，使用`guess_parser()`函数返回`readr`最可信的猜测，接着`parse_guess()`函数使用这个猜测来解析列。

### 问题

按照上面的策略来进行当然不可能万无一失。可能遇到的问题：

- 前 1000 行可能是一种特殊情况，`readr`猜测出的类型不足以代表整个文件。

- 列中可能含有大量缺失值。

> 每个`parse_xyz()`函数都有一个对应的`col_xyz()`函数。如果数据已经保存在R的字符向量中那么你可以使用`parse_xyz()`；如果想要告诉`readr`如何加载数据，则应该使用`col_xyz()`。
我们强烈建议你总是提供`col_types`参数，从`readr`打印出的输出中可以知道它的值。这可以确保数据导入脚本的一致性，并可以重复使用。如果不提供这个参数，而是依赖猜测的类型，那么当数据发生变化时，`readr`会继续读入数据。如果想要严格解析，可以使用`stop_for_problems()`函数：当出现任何解析问题时，它会抛出一个错误，并终止脚本。

### 其他策略

对于上面的问题，我们需要其他的策略：

- 设置`guess_max`读多几行数据

- 将所有列都作为字符向量读入，再结合`type_convert()`函数

- 如果正在读取一个非常大的文件，那么你应该将`n_max`设置为一个较小的数，比如10 000或者100 000。这可以让你在解决常见问题时加快重复试验的过程。

- 如果遇到严重的解析问题，有时使用`read_lines()`函数按行读入字符向量会更容易，甚至可以使用`read_file()`函数读入一个长度为1的字符向量。接着你可以使用后面将学到的字符串解析技能来解析各种各样的数据形式。

后两个策略暂时不太明白...

## 写入文件

<div align=center>![](08-data-import_files/写入文件.png){width=70%}</div>

## 练习

（1）有时CSV文件中的字符串会包含逗号。为了防止引发问题，需要用引号（如 " 或 '）将逗号围起来。按照惯例，`read_csv()`默认引号为"，如果想要改变默认值，就要转而使用`read_delim()`函数。要想将以下文本读入一个数据框，需要设定哪些参数？

```{r}
x <- "x,y\n1,'a,b'"
read_csv(x,quote = "'")
```

通过设置`quote`参数指定引号。

（2）找出以下每个行内 CSV 文件中的错误。如果运行代码，会发生什么情况？
```{r}
read_csv("a,b\n1,2,3\n4,5,6") 
read_csv("a,b,c\n1,2\n1,2,3,4") 
```
列数不匹配，不是矩形数据。`read_csv`以第一列列数识别为文件列数，后面的数据列数不够部为NA，超过的截断。


```{r}
x <- "a,b\n\"1"
cat(x)
read_csv(x) 
```

估计是把`"1`识别为整数`1`。

```{r}
read_csv("a,b\n1,2\na,b") 
```
```{r}
read_csv("a;b\n1;3")
```

将`a;b`与`1;3`识别为字符串了。

