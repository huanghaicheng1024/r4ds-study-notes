[["index.html", "r4ds学习笔记 背景", " r4ds学习笔记 Huang 2020-11-23 背景 开始正式学习《R for data science》(https://r4ds.had.co.nz/) 2020-8-29 "],["intro.html", "1 Introduction", " 1 Introduction 这本书主要讲解的，是如何使用非常重要的数据科学工具，并给出了工具模型 其大致的含义如下： "],["explore-intro.html", "2 Introduction", " 2 Introduction 首先开始讲解的是数据探索这部分内容。 数据探索是一门艺术，它是审视数据、生成假设、假设检验的不断反复的过程。 "],["data-visualisation.html", "3 Data visualisation 3.1 Introduction 3.2 First steps 3.3 Aesthetic mappings 3.4 Common problems 3.5 Facets分面 3.6 几何对象 3.7 统计变换 3.8 位置调整 3.9 坐标系 3.10 图形分层语法", " 3 Data visualisation 3.1 Introduction 我们将要学习的第一套工具，ggplot2的程序包，用于绘图。 首先加载tidyverse library(tidyverse) #&gt; -- Attaching packages ---------------- #&gt;  ggplot2 3.3.2  purrr 0.3.4 #&gt;  tibble 3.0.3  dplyr 1.0.2 #&gt;  tidyr 1.1.1  stringr 1.4.0 #&gt;  readr 1.3.1  forcats 0.5.0 #&gt; -- Conflicts ------------------------- #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() 3.2 First steps 先绘制一个mpg数据框里边的引擎大小(displ)-燃油效率(hwy)散点图 ggplot(data = mpg)+ geom_point(mapping = aes(x = displ,y = hwy)) 可以看到，绘图的模板命令大致是 ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) ggplot(data = &lt;DATA&gt;) 这是在生成一个空白图层，指定数据。 &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) 这是在空白图层上方继续加图层，比如前面的geom_point就是加上散点图图层。mapping是映射，是将数据框的属性映射成图形属性，常见的我们还用aes()，这是将将数据框的属性映射成x,y轴变量。 3.2.1 Exercises 运行ggplot(data = mpg)，你会看到什么？ ggplot(data = mpg) 显然，是一个空白的图层。 数据集mpg中有多少行？多少列？ str(mpg) #&gt; tibble [234 x 11] (S3: tbl_df/tbl/data.frame) #&gt; $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... #&gt; $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... #&gt; $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... #&gt; $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... #&gt; $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... #&gt; $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... #&gt; $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... #&gt; $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... #&gt; $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... #&gt; $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... #&gt; $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... 利用str函数，可以得到数据集mpg中有234行11列。 变量drv的意义是什么？使用?mpg命令阅读帮助文件以找出答案。 ?mpg 通过阅读帮助文档可以知道 drv: the type of drive train, where f = front-wheel drive, r = rear wheel drive, 4 = 4wd 即传动系的类型，f表示前轮驱动，r表示后轮驱动，4表示四轮驱动。 使用hwy和cyl绘制一张散点图。 ggplot(data = mpg)+ geom_point(mapping = aes(x = hwy,y = cyl)) 啊，这奇怪的图形。 如果使用class和drv绘制散点图，会发生什么情况？为什么这张图没什么用处？ ggplot(data = mpg)+ geom_point(mapping = aes(x = class,y = drv)) 会出现很多点重合的现象，这是这张图没什么用处的原因吗？但是自我感觉还是保留了些许信息，但的确被压缩了很多。 3.3 Aesthetic mappings 我们在前面学习了如何把数据框属性映射为x,y轴，实际上还可以映射其他图形属性。 在引擎大小(displ)-燃油效率(hwy)散点图中增加多一个映射，将点的颜色映射为变量class ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) 类似于点的颜色，还有的图形属性为： 点的透明度alpha 点的大小size，单位为毫米 点的形状shape，ggplot2只能同时使用6种形状 还可以通过?geom_point来查看 除了映射图形属性让ggplot2帮忙设置，还可以手动为几何对象设置图形属性。 ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy),colour = &#39;blue&#39;) 上图会将所有点都绘制成蓝色，因为我们并没有对点的颜色建立映射，而是直接设置。这与前面的图不同。 3.3.1 Exercises 以下这段代码有什么错误？为什么点不是蓝色的？ ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;) ) 这是因为这段代码把字符串常量当作数据框属性映射为点的颜色，由于各点的值都是常量“blue”故大家的颜色也一样，为默认的第一种颜色：红色。 事实上， ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = &quot;hello&quot;) ) 不论那个字符串是什么，甚至不是颜色的字符串也没有什么影响的。 (2)mpg中的哪些变量是分类变量？哪些变量是连续变量？（提示：输入?mpg来阅读这个数据集的文档。）当调用mpg时，如何才能看到这些信息？ 当然可以阅读文档，但也可以 str(mpg) #&gt; tibble [234 x 11] (S3: tbl_df/tbl/data.frame) #&gt; $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... #&gt; $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... #&gt; $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... #&gt; $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... #&gt; $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... #&gt; $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... #&gt; $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... #&gt; $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... #&gt; $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... #&gt; $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... #&gt; $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... summary(mpg) #&gt; manufacturer model displ year #&gt; Length:234 Length:234 Min. :1.60 Min. :1999 #&gt; Class :character Class :character 1st Qu.:2.40 1st Qu.:1999 #&gt; Mode :character Mode :character Median :3.30 Median :2004 #&gt; Mean :3.47 Mean :2004 #&gt; 3rd Qu.:4.60 3rd Qu.:2008 #&gt; Max. :7.00 Max. :2008 #&gt; cyl trans drv cty #&gt; Min. :4.00 Length:234 Length:234 Min. : 9.0 #&gt; 1st Qu.:4.00 Class :character Class :character 1st Qu.:14.0 #&gt; Median :6.00 Mode :character Mode :character Median :17.0 #&gt; Mean :5.89 Mean :16.9 #&gt; 3rd Qu.:8.00 3rd Qu.:19.0 #&gt; Max. :8.00 Max. :35.0 #&gt; hwy fl class #&gt; Min. :12.0 Length:234 Length:234 #&gt; 1st Qu.:18.0 Class :character Class :character #&gt; Median :24.0 Mode :character Mode :character #&gt; Mean :23.4 #&gt; 3rd Qu.:27.0 #&gt; Max. :44.0 将一个连续变量映射为color、size和shape。对分类变量和连续变量来说，这些图形 属性的表现有什么不同？ 实践是检验真理的唯一标准，我们试试看： ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = cty) ) ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, size = cty) ) ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, shape = cty) ) 前两个还好，后面这个形状是直接报错无法映射了。毕竟color还有size都是可以渐变也即可以建立连续映射到连续的，但是形状就是铁定的离散值了，无法与连续值建立映射。 (4)如果将同一个变量映射为多个图形属性，会发生什么情况？ 试试看： ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, colour = class, size = class) ) #&gt; Warning: Using size for a discrete variable is not advised. 咦，会叠加的耶。 (5)stroke这个图形属性的作用是什么？它适用于哪些形状？（提示：使用?geom_point命令。） ?geom_point 但是里面没有具体涉及。实践一下 ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, stroke = cty*0.2, size = cty) ) 查阅https://ggplot2.tidyverse.org/articles/ggplot2-specs.html#colour-and-fill-1， stroke这个图形属性是用于21-24形状的点的描边大小。 如果将图形属性映射为非变量名对象，比如aes(color = displ &lt; 5)，会发生什么情况？ ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = displ &lt; 5) ) 嗯，还是可以映射成图形属性的。 3.4 Common problems 这样子是错的 ggplot(data = mpg) +geom_point(mapping = aes(x = displ, y = hwy, color = class)) 加号要放在代码的末尾。 3.5 Facets分面 一个参数的分面：利用函数facet_wrap()。例如： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) 每一个“面”都是属性class的一个值，所以传递给facet_wrap()的变量应该是离散型的。参数nrow表示分面的行数。 两个参数的分面：利用函数facet_grid()。例如： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl) 每一个面都由(cyl,drv)决定。 ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) 想要取消在行的维度分面，用.替代属性。 3.5.1 Exercises 如果使用连续变量进行分面，会发生什么情况？ 看一个参数的： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ cty, nrow = 2) 可以看到它会把连续变量的所有取值都绘制分面了。 在使用facet_grid(drv ~ cyl)生成的图中，空白单元的意义是什么？它们和以下代码 生成的图有什么关系？ ggplot(data = mpg) + geom_point(mapping = aes(x = drv, y = cyl)) 而 ggplot(data = mpg) + facet_grid(drv ~ cyl) 这个图只是对变量drv,cyl绘制分面，而上图是对这两个变量绘制散点图。 以下代码会绘制出什么图？ . 的作用是什么？ ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ .) ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) 这两幅图实际上是按单个变量按列或行分面，与facet_warp()不同之处： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ cyl) facet_warp()对单个变量分面不会考虑按行或者按列。 查看本节的第一个分面图， 与使用图形属性相比，使用分面的优势和劣势分别是什么？如果有一个更大的数据集，你将如何权衡这两种方法的优劣？ 使用分面的优势：可以更好地看清，在固定某个变量（上图的class）时其余两个变量的关系。劣势就是三个变量的共同作用不太好看清了。 所以我觉得，当我们要考虑多个变量的共同作用、相互关系时可以考虑使用图形属性，当我们想要固定某个变量考虑其他变量时可以考虑分面。 阅读?facet_wrap的帮助页面。nrow和ncol的功能分别是什么？还有哪些选项可以控 制分面的布局？为什么函数facet_grid()没有变量nrow和ncol？ nrow和ncol的功能分别是控制分面图的行列个数。函数facet_grid()的行列数是依赖于分面变量的取值数，所以无法自定义。 在使用函数facet_grid()时，一般应该将具有更多唯一值的变量放在列上。为什么这么做呢？ 增加分面图的行数，从而每幅图看起来更好看、清晰，吧。 3.6 几何对象 几何对象是图中用来表示数据的几何图形对象，在ggplot2中使用几何对象函数来实现，比如 geom_point(),geom_smooth()等等，对于同一个数据对象，使用什么样的几何对象来展示，这估计也是一个大学问啊。 ggplot2中每个几何对象函数都有mapping参数，但并不意味着可以任意设置所有的图形属性，比如geom_point()就没有linetype属性。每个几何对象的详情可以使用帮助?geom_point。 3.6.1 分组绘图 使用单一几何对象实现分组绘图： 将一个图形属性映射为一个离散变量，自动添加图例（巨方便） ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, color = drv)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 使用group参数 ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 3.6.2 多个几何对象 想要在一幅图上显示多个几何对象，只需要把图层不断叠加。例如： ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))+ geom_point(mapping = aes(x = displ, y = hwy)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 可以看到，两个几何对象的映射是重复的，可以用全局映射替代。即 ggplot(data = mpg,mapping = aes(x = displ, y = hwy))+ geom_point()+ geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 这样修改全局映射就会对所有几何对象有影响。 关于全局映射与局部映射：全局映射会作用与所有几何对象，局部映射只会作用与当前几何对象，并且局部映射可以拓展（不冲突时）或者覆盖全局映射（冲突时）。对于全局指定数据集以及局部指定数据集也类似。例如， ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth( data = filter(mpg, class == &quot;subcompact&quot;), se = FALSE ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 上例中，全局指定数据集与局部指定数据集冲突，所以几何对象geom_smooth只绘制了局部指定的数据集。局部映射color = class与全局映射不冲突，所以几何对象geom_point被三个映射作用。 3.6.3 练习 在绘制折线图、箱线图、直方图和分区图时，应该分别使用哪种几何对象？ 参考： https://ggplot2.tidyverse.org/reference/index.html。 在脑海中运行以下代码，并预测会有何种输出。接着在R中运行代码，并检查你的预测是否正确。 预测：对数据中变量drv不同值分别绘制散点图并绘制该散点图的平滑拟合曲线。 实际： ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = drv) ) + geom_point() + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 嗯，一样的。 show.legend = FALSE的作用是什么？删除它会发生什么情况？你觉得我为什么要在本 章前面的示例中使用这句代码？ 作用是不显示图例，删除它就显示图例呗。为了体现将一个图形属性映射为一个离散变量时ggplot2可以自动添加图例。 geom_smooth()函数中的se参数的作用是什么？ ?geom_smooth 可以看到se参数的作用是控制是否展示拟合曲线的置信区间。 以下代码生成的两张图有什么区别吗？为什么？ ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot() + geom_point( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_smooth( data = mpg, mapping = aes(x = displ, y = hwy) ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 一样的呀，不就是把全局变量放在局部变量那里吗… 自己编写R代码来生成以下各图。 ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth(se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth( mapping = aes(group=drv),se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy,color=drv)) + geom_point() + geom_smooth(se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color=drv)) + geom_smooth(se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color=drv)) + geom_smooth(se=F,mapping = aes(linetype=drv)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color=drv)) 3.7 统计变换 很多图形绘制的是数据集的原始数据，比如散点图,它把原始数据中已有的变量映射到图形属性中。 另外一些图形则可以绘制那些计算出的新数据，比如条形图。例如， ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) y轴的count变量是原始数据中所没有的，是通过统计变换（stat）后得到的。所以对于这些函数，它们作用的过程可以分为两步，先是处理原始数据集，后是将处理后的数据集的变量映射到图形属性。但我们往往不需要关注底层统计变换的实现过程。 3.7.1 底层实现 当我们需要关注底层实现过程的时候，我们需要知道： 通过查看stat参数的默认值，可以知道几何对象函数使用了哪种统计变换函数。统计函数会计算出不止一个新变量，例如可以通过?geom_bar的Computed variables一节看到。 统计变换函数指的是实现某种统计变换的函数，例如count-&gt;stat_count()。 通常来说，几何对象函数和统计变换函数可以互换使用，如geom_bar与stat_count，因为每个几何对象函数都有一个默认统计变换，每个统计变换函数都有一个默认几何对象 3.7.2 显式使用 当我们想要显式使用某种统计变换时， 想要覆盖默认的统计变换：更改stat参数值，并指定各图形属性的映射。例 demo &lt;- tribble( ~a, ~b, &quot;bar_1&quot;, 20, &quot;bar_2&quot;, 30, &quot;bar_3&quot;, 40 ) ggplot(data = demo) + geom_bar( mapping = aes(x = a, y = b), stat = &quot;identity&quot; ) ggplot(data = demo) + geom_bar( mapping = aes(x = a) ) 其中，stat = \"identity\"表示不使用统计变换（即使用恒等变换）。 想要覆盖从统计变换生成的变量到图形属性的默认映射。 前面我们说过，统计函数会计算出不止一个新变量，我们可以显示地更改变量到图形属性的默认映射，例如，默认的： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut) ) stat_count计算的变量除了count（默认映射）还有prop，更改一下映射： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..prop.., group = 1) ) 可以看到y = ..prop..而不是y = prop估计是为了表明这个prop是统计变换计算出来的中间变量，而不是原始数据中的变量。验证一下： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..count.., group = 1) ) 可以得到默认的绘图。 想要在代码中强调统计变换。而非几何对象。如 ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.min = min, fun.max = max, fun = median ) 3.7.3 练习 stat_summary()函数的默认几何对象是什么？不使用统计变换函数的话，如何使用几何对象函数重新生成以上的图？ 可以看到geom = \"pointrange\"，从而默认的几何对象为geom_pointrange。利用pointrange生成图如下： ggplot(data = diamonds) + geom_pointrange( mapping = aes(x = cut, y = depth), stat = &quot;summary&quot;, fun.min = min, fun.max = max, fun = median ) 默认是不做统计变换，所以要显示指定一下参数stat。 geom_col()函数的功能是什么？它和geom_bar()函数有何不同？ geom_col()函数默认不使用统计变换，即需要把原始数据中某个变量映射到y轴上。geom_bar()函数默认使用统计变换。 多数几何对象和统计变换都是成对出现的，总是配合使用。仔细阅读文档，列出所有 成对的几何对象和统计变换。它们有什么共同之处？ 参考：https://ggplot2.tidyverse.org/reference/index.html 。名字大多类似？ stat_smooth()函数会计算出什么变量？哪些参数可以控制它的行为？ y：预测值，ymin,ymax：y均值的置信区间，se：标准误差。嗯…太多了… 在比例条形图中，我们需要设定group = 1，这是为什么呢？换句话说，以下两张图会 有什么问题？ ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop..)) ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = color, y = ..prop..) ) 你需要把所有数据放在一个组里面考虑，否则对于cut的每一个值分为一组，prop值都会是1。只需要把一个常量映射为group参数即可。 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop..,group=&quot;hello&quot;)) 3.8 位置调整 3.8.1 条形图上色 使用color或者fill图形属性 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, color = cut)) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut)) 可以看到，color为边框上色，fill为图形填充颜色。 改变fill映射的变量，可以得到分块堆砌条形图。 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity)) 3.8.2 位置调整功能 这是由position参数设定的位置调整功能自动完成的，默认为stack（堆砌），还有其余值为identity,fill,dodge。 position = \"identity\"：将每个对象直接显示在图中，在图层上进行堆砌。这种方式不太适合条形图，因为条形会彼此重叠。为了让重叠部分能够显示出来，我们可以设置alpha参数为一个较小的数，从而使得条形略微透明；或者设定fill = NA，让条形完全透明： ggplot( data = diamonds, mapping = aes(x = cut, fill = clarity) ) + geom_bar(alpha = 1/5, position = &quot;identity&quot;) ggplot( data = diamonds, mapping = aes(x = cut, color = clarity) ) + geom_bar(fill = NA, position = &quot;identity&quot;) position = \"fill\"：与堆叠相似，但每组堆叠条形具有同样的高度，因此这种条形图可以非常轻松地比较各组间的比例： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = &quot;fill&quot; ) position = \"dodge\"将每组中的条形依次并列放置，这样可以非常轻松地比较每个条形 表示的具体数值： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = &quot;dodge&quot; ) position = \"jitter\"：虽然不适合条形图，但非常适合散点图。它为每个数据点添加一个很小的随机扰动，这样就可以将重叠的点分散开来。用损失精确性的方法提高图形的启发性，我觉得想法非常棒呀，毕竟图形化本身就是在用降低精确性来提高启发性。 ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy), position = &quot;jitter&quot; ) 3.8.3 练习 (1)以下图形有什么问题？应该如何改善？ ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() 重叠点太多，加入随机扰动看看： ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_jitter() 效果要好一点。 (2)geom_jitter()使用哪些参数来控制抖动的程度？ width,height，但不太清楚作用机制… (3)对比 geom_jitter() 与 geom_count()。 geom_jitter()通过对数据点加随机扰动把重叠点分开，而 geom_count()对于重叠点，将重叠点计数映射到改区域点的大小。即 ggplot(mpg, aes(cty, hwy)) + geom_count() (4)geom_boxplot()函数的默认位置调整方式是什么？创建mpg数据集的可视化表示来演示一下。 默认位置调整方式是dodge2。 ggplot(mpg, aes(class, hwy))+ geom_boxplot() 3.9 坐标系 coord_flip()交换x轴，y轴； coord_quickmap()为地图设置合适的纵横比； coord_polar()采用极坐标； 3.9.1 练习 (1)使用coord_polar()函数将堆叠式条形图转换为饼图。 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity))+ coord_polar() (2)labs()函数的功能是什么？阅读一下文档。 修改标签。 (3)coord_quickmap()函数和 coord_map() 函数的区别是什么？ 参考：https://ggplot2.tidyverse.org/reference/coord_map.html (4)下图表明城市和公路燃油效率之间有什么关系？为什么coord_fixed()函数很重要？geom_abline() 函数的作用是什么？ ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() + coord_fixed() 正相关（线性）。可以使数据点（看起来）成斜率为1或-1，否则就是 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() geom_abline() 函数的作用是绘制参考直线。 3.10 图形分层语法 模板语法： ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; 如果构建一个图形？ 1.需要有一个数据集&lt;DATA&gt; 2.（通过统计变换&lt;STAT&gt;）将其转换为想要显示的信息 3.选择一个几何对象&lt;GEOM_FUNCTION&gt;来表示转换后的数据中的每个观测值， 4.选择几何对象的图形属性来表示数据中的变量，这会将每个变量的值映射&lt;MAPPINGS&gt;为图形属性的水平。 5.选择放置几何对象的坐标系&lt;COORDINATE_FUNCTION&gt; 6.进一步调整几何对象在坐标系中的位置（位置调整&lt;POSITION&gt;），或者将图划分为多个子图（分面&lt;FACET_FUNCTION&gt;） 7.添加一个或多个附加图层进行拓展。 "],["workflow-basics.html", "4 Workflow: basics 4.1 代码基础 4.2 对象名称 4.3 函数调用 4.4 练习", " 4 Workflow: basics 4.1 代码基础 在RStudio中R代码块中使用Alt加减号键，可以打出&lt;-并且左右加上空格，贼方便呀。 4.2 对象名称 对象名称必须以字母开头，并且只能包含字母、数字、_ 和 .。如何命名一个对象看个人习惯吧，最好就是能具有描述性。 4.3 函数调用 无 4.4 练习 (1)为什么以下代码不能正常运行？ my_variable &lt;- 10 my_varıable 上下两个对象名称不同的… (2)修改以下每段 R 代码，使其可以正常运行。 library(tidyverse) ggplot(data = mpg) + # dota-&gt;data geom_point(mapping = aes(x = displ, y = hwy)) filter(mpg, cyl == 8) # fliter-&gt;filter,= -&gt; == filter(diamonds, carat &gt; 3) # diamond -&gt; diamonds (3)按 Alt+Shift+K 组合键会发生什么情况？如何使用菜单完成同样的操作？ 打开键盘快捷键帮助。菜单操作：Tools-&gt;Keyboard Shortcuts Help "],["data-transformation.html", "5 Data transformation 5.1 简介 5.2 使用filter()筛选行 5.3 使用arrange()排列行 5.4 使用select()选择列 5.5 使用mutate()添加新变量 5.6 使用summarize()进行分组摘要 5.7 分组新变量（和筛选器）", " 5 Data transformation 5.1 简介 原始数据总是不会让人满意，为了满足自己分析的需求，对数据进行转换不可避免。这一章我们要学习的是dplyr包，用于转换数据。 5.1.1 准备工作 载入tidyverse跟nycflights13包： library(nycflights13) library(tidyverse) 5.1.2 tibble变量类型 • int 表示整数型变量。 • dbl 表示双精度浮点数型变量，或称实数。 • chr 表示字符向量，或称字符串。 • dttm 表示日期时间（日期 + 时间）型变量。 • lgl 表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。 • fctr 表示因子，R 用其来表示具有固定数目的值的分类变量。 • date 表示日期型变量 实际上就是英文缩写，比较好记。 5.1.3 dplyr基础 下面五个函数的工作方式是相同的： 第一个参数是一个数据框。 随后的参数使用变量名称（不带引号）描述了在数据框上进行的操作。 输出结果是一个新数据框。 这样的属性可以让我们在后面很方便地使用管道实现复杂的数据处理。 5.2 使用filter()筛选行 filter()的一般使用方法如下： filter(flights,month == 1, day == 1) #&gt; # A tibble: 842 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 836 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 第一个参数是数据框，后面的参数是筛选数据框行的表达式。 关于筛选数据框行的表达式，我们常常需要用到： 比较运算符，&gt;、&gt;=、&lt;、&lt;=、!=（不等于）和 ==（等于） 逻辑运算符，&amp;、|、！（而不是&amp;&amp;，||） 其他，像 %in%, between 5.2.1 练习 (1)找出满足以下条件的所有航班。 a.到达时间延误 2 小时或更多的航班。 filter(flights,arr_delay&gt;=2*60) #&gt; # A tibble: 10,200 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 811 630 101 1047 830 #&gt; 2 2013 1 1 848 1835 853 1001 1950 #&gt; 3 2013 1 1 957 733 144 1056 853 #&gt; 4 2013 1 1 1114 900 134 1447 1222 #&gt; 5 2013 1 1 1505 1310 115 1638 1431 #&gt; 6 2013 1 1 1525 1340 105 1831 1626 #&gt; # ... with 10,194 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; b.飞往休斯顿（IAH 机场或 HOU 机场）的航班。 filter(flights,dest %in% c(&quot;IAH&quot;,&quot;HOU&quot;)) #&gt; # A tibble: 9,313 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 623 627 -4 933 932 #&gt; 4 2013 1 1 728 732 -4 1041 1038 #&gt; 5 2013 1 1 739 739 0 1104 1038 #&gt; 6 2013 1 1 908 908 0 1228 1219 #&gt; # ... with 9,307 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; c.由联合航空（United）、美利坚航空（American）或三角洲航空（Delta）运营的航班。 filter(flights,carrier %in% c(&quot;UA&quot;,&quot;AA&quot;,&quot;DL&quot;)) #&gt; # A tibble: 139,504 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 554 600 -6 812 837 #&gt; 5 2013 1 1 554 558 -4 740 728 #&gt; 6 2013 1 1 558 600 -2 753 745 #&gt; # ... with 139,498 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; d.夏季（7 月、8 月和 9 月）出发的航班。 filter(flights,month %in% c(7,8,9)) #&gt; # A tibble: 86,326 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 7 1 1 2029 212 236 2359 #&gt; 2 2013 7 1 2 2359 3 344 344 #&gt; 3 2013 7 1 29 2245 104 151 1 #&gt; 4 2013 7 1 43 2130 193 322 14 #&gt; 5 2013 7 1 44 2150 174 300 100 #&gt; 6 2013 7 1 46 2051 235 304 2358 #&gt; # ... with 86,320 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; e.到达时间延误超过 2 小时，但出发时间没有延误的航班。 filter(flights,arr_delay&gt;=2*60,dep_delay&lt;=0) #&gt; # A tibble: 29 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 27 1419 1420 -1 1754 1550 #&gt; 2 2013 10 7 1350 1350 0 1736 1526 #&gt; 3 2013 10 7 1357 1359 -2 1858 1654 #&gt; 4 2013 10 16 657 700 -3 1258 1056 #&gt; 5 2013 11 1 658 700 -2 1329 1015 #&gt; 6 2013 3 18 1844 1847 -3 39 2219 #&gt; # ... with 23 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; f.延误至少 1 小时，但飞行过程弥补回 30 分钟的航班。 也就是，出发时间延误超1小时，但出发时间延误-到达时间延误&gt;=30min filter(flights,dep_delay&gt;=1*60,dep_delay-arr_delay&gt;=30) #&gt; # A tibble: 2,074 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 1716 1545 91 2140 2039 #&gt; 2 2013 1 1 2205 1720 285 46 2040 #&gt; 3 2013 1 1 2326 2130 116 131 18 #&gt; 4 2013 1 3 1503 1221 162 1803 1555 #&gt; 5 2013 1 3 1821 1530 171 2131 1910 #&gt; 6 2013 1 3 1839 1700 99 2056 1950 #&gt; # ... with 2,068 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; g.出发时间在午夜和早上 6 点之间（包括 0 点和 6 点）的航班。 filter(flights,dep_time&gt;=0&amp;dep_time&lt;=600) #&gt; # A tibble: 9,344 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 9,338 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (2)dplyr中对筛选有帮助的另一个函数是between()。它的作用是什么？你能使用这个函数来简化解决前面问题的代码吗？ 用于实现letf&lt;=x&lt;=right的表达式。上面的g也可以写成 filter(flights,between(dep_time,0,600)) #&gt; # A tibble: 9,344 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 9,338 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (3)dep_time 有缺失值的航班有多少？其他变量的缺失值情况如何？这样的行表示什么情况？ filter(flights,is.na(dep_time)) #&gt; # A tibble: 8,255 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 NA 1630 NA NA 1815 #&gt; 2 2013 1 1 NA 1935 NA NA 2240 #&gt; 3 2013 1 1 NA 1500 NA NA 1825 #&gt; 4 2013 1 1 NA 600 NA NA 901 #&gt; 5 2013 1 2 NA 1540 NA NA 1747 #&gt; 6 2013 1 2 NA 1620 NA NA 1746 #&gt; # ... with 8,249 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; dep_delay,arr_time,arr_delay同时缺失，表示航班取消。 (4)为什么 NA ^ 0 的值不是 NA ？为什么 NA | TRUE 的值不是 NA ？为什么 FALSE &amp; NA 的值不是 NA ？你能找出一般规律吗？（NA * 0 则是精妙的反例！） 个人觉得，因为NA表示缺失值，所有有可能取到可取的任意值。 对于NA^0，NA*0等数学运算，NA可以取任意数值，对于NA所取任意值，如果表达式的值都唯一，那么这个就是该表达式的值，若不唯一，则应为NA。由于对于任意数值，它的0次幂都为1（包括Inf、-Inf），所以NA^0==1，而由于Inf*0=NaN，当NA取1时NA*0==0，不唯一，故NA * 0=NA。 对于NA | TRUE，FALSE &amp; NA，NA可以取TRUE或者FALSE，无论取什么值，两个表达式的值都唯一（分别为TRUE，FALSE），故它们的值都不是NA。 5.3 使用arrange()排列行 工作方式： arrange(flights,year,month,day) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 将数据框flights的行按照year,month,day的值升序排序，返回新的数据框。 使用 desc() 可以按列进行降序排序： arrange(flights,desc(dep_delay)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 此外，缺失值总是排在最后。 5.3.1 练习 (1)如何使用 arrange() 将缺失值排在最前面？（提示：使用 is.na()。） df &lt;- tibble(x = c(5, 2, NA)) arrange(df,desc(is.na(df))) #&gt; # A tibble: 3 x 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 NA #&gt; 2 5 #&gt; 3 2 不知道这算不算一个好的办法。但是要改变非缺失值顺序的同时又把缺失值放在前面，就有点复杂了，需要arrange两次。 (2)对ﬂights排序以找出延误时间最长的航班。找出出发时间最早的航班。 arrange(flights,desc(arr_delay)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange(flights,dep_time) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 13 1 2249 72 108 2357 #&gt; 2 2013 1 31 1 2100 181 124 2225 #&gt; 3 2013 11 13 1 2359 2 442 440 #&gt; 4 2013 12 16 1 2359 2 447 437 #&gt; 5 2013 12 20 1 2359 2 430 440 #&gt; 6 2013 12 26 1 2359 2 437 440 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (3)对flights排序以找出速度最快的航班。 需要根据distance（距离）以及air_time（飞行时间）去计算速度，并排序： arrange(flights,desc(distance/air_time)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 5 25 1709 1700 9 1923 1937 #&gt; 2 2013 7 2 1558 1513 45 1745 1719 #&gt; 3 2013 5 13 2040 2025 15 2225 2226 #&gt; 4 2013 3 23 1914 1910 4 2045 2043 #&gt; 5 2013 1 12 1559 1600 -1 1849 1917 #&gt; 6 2013 11 17 650 655 -5 1059 1150 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (4)哪个航班的飞行时间最长？哪个最短？ arrange(flights,air_time) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 16 1355 1315 40 1442 1411 #&gt; 2 2013 4 13 537 527 10 622 628 #&gt; 3 2013 12 6 922 851 31 1021 954 #&gt; 4 2013 2 3 2153 2129 24 2247 2224 #&gt; 5 2013 2 5 1303 1315 -12 1342 1411 #&gt; 6 2013 2 12 2123 2130 -7 2211 2225 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange(flights,desc(air_time)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 3 17 1337 1335 2 1937 1836 #&gt; 2 2013 2 6 853 900 -7 1542 1540 #&gt; 3 2013 3 15 1001 1000 1 1551 1530 #&gt; 4 2013 3 17 1006 1000 6 1607 1530 #&gt; 5 2013 3 16 1001 1000 1 1544 1530 #&gt; 6 2013 2 5 900 900 0 1555 1540 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 5.4 使用select()选择列 使用方法： select(dataframe,other) other一般可以有： 多个变量名标量 变量名向量 辅助函数，用于匹配变量名，或者将变量移到数据框前面（everything()） 位于前面的变量名参数的优先级更高，如果跟后面的变量名参数冲突（相同）会覆盖它。（可以参考练习(2)）。 5.4.1 练习 (1)从flights数据集中选择dep_time、dep_delay、arr_time和arr_delay，通过头脑风暴找出尽可能多的方法。 select(flights,dep_time,dep_delay,arr_time,arr_delay) # 原始方法 select(flights,dep_time:arr_delay,-c(sched_dep_time,sched_arr_time)) # 向量方法 select(flights,dep_time:arr_delay,-starts_with(&quot;sched&quot;)) # 利用辅助函数匹配需要舍弃的变量名 select(flights,starts_with(&quot;dep&quot;),starts_with(&quot;arr&quot;)) # 直接匹配变量名 select(flights,matches(&quot;^(dep|arr)&quot;)) # 利用正则匹配 (2)如果在select()函数中多次计入一个变量名，那么会发生什么情况？ select(flights,dep_time,dep_time) #&gt; # A tibble: 336,776 x 1 #&gt; dep_time #&gt; &lt;int&gt; #&gt; 1 517 #&gt; 2 533 #&gt; 3 542 #&gt; 4 544 #&gt; 5 554 #&gt; 6 554 #&gt; # ... with 336,770 more rows 只会选取一列。这就解释了为什么： select(flights, time_hour, air_time, everything()) #&gt; # A tibble: 336,776 x 19 #&gt; time_hour air_time year month day dep_time sched_dep_time #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013-01-01 05:00:00 227 2013 1 1 517 515 #&gt; 2 2013-01-01 05:00:00 227 2013 1 1 533 529 #&gt; 3 2013-01-01 05:00:00 160 2013 1 1 542 540 #&gt; 4 2013-01-01 05:00:00 183 2013 1 1 544 545 #&gt; 5 2013-01-01 06:00:00 116 2013 1 1 554 600 #&gt; 6 2013-01-01 05:00:00 150 2013 1 1 554 558 #&gt; # ... with 336,770 more rows, and 12 more variables: dep_delay &lt;dbl&gt;, #&gt; # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt; 会把变量移到前面。 (3)one_of()函数的作用是什么？为什么它结合以下向量使用时非常有用？ vars &lt;- c( &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;dep_delay&quot;, &quot;arr_delay&quot;, &quot;hello&quot; ) select(flights,one_of(vars)) #&gt; Warning: Unknown columns: `hello` #&gt; # A tibble: 336,776 x 5 #&gt; year month day dep_delay arr_delay #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 #&gt; 2 2013 1 1 4 20 #&gt; 3 2013 1 1 2 33 #&gt; 4 2013 1 1 -1 -18 #&gt; 5 2013 1 1 -6 -25 #&gt; 6 2013 1 1 -4 12 #&gt; # ... with 336,770 more rows 选取数据框中包含在vars中的变量。 (4)以下代码的运行结果是否出乎意料？选择辅助函数处理大小写的默认方式是什么？如何改变默认方式？ select(flights, contains(&quot;TIME&quot;)) #&gt; # A tibble: 336,776 x 6 #&gt; dep_time sched_dep_time arr_time sched_arr_time air_time time_hour #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dttm&gt; #&gt; 1 517 515 830 819 227 2013-01-01 05:00:00 #&gt; 2 533 529 850 830 227 2013-01-01 05:00:00 #&gt; 3 542 540 923 850 160 2013-01-01 05:00:00 #&gt; 4 544 545 1004 1022 183 2013-01-01 05:00:00 #&gt; 5 554 600 812 837 116 2013-01-01 06:00:00 #&gt; 6 554 558 740 728 150 2013-01-01 05:00:00 #&gt; # ... with 336,770 more rows 有点出乎意料…查阅文档可以知道，那几个匹配的函数都有参数ignore.case（忽略大小写），默认为TRUE，修改一下就行了。 select(flights, contains(&quot;TIME&quot;,ignore.case = F)) #&gt; # A tibble: 336,776 x 0 5.5 使用mutate()添加新变量 我们可以使用mutate()添加新变量，也就是新的列，它往往是原有列的函数。 mutate()总是将新列添加在数据集的最后 一旦创建，新列就可以立即使用。不用等到返回数据框再使用新列。 如果只想保留新变量，可以使用transmute()函数。使用mutate()函数会保留原数据框的所有列，新列加在后面。 5.5.1 常用创建函数 创建新变量的多种函数可供同mutate()一同使用。最重要的一点是，这种函数必须是向 量化的。这个不难理解，毕竟我们是输入原有列（向量）而得到新列（向量）。 主要有： 算术运算符：+、-、*、/、^ 模运算符：%/%（整除） 和 %%（求余） 对数函数：log()、log2() 和 log10() 偏移函数：lead()、lag() 累加和滚动聚合：cumsum()、cumprod()、commin() 和 cummax()，以及cummean() 逻辑比较：&lt;、&lt;=、&gt;、&gt;= 和 != 排秩：min_rank()、 row_number()、dense_rank()、percent_rank()、cume_dist()和 ntile() 5.5.2 练习 (1)虽然现在的dep_time和sched_dep_time变量方便阅读，但不适合计算，因为它们实际上并不是连续型数值。将它们转换成一种更方便的表示形式，即从午夜开始的分钟数。 transmute(flights, dep_min=(dep_time %/% 100)*60+(dep_time %% 100), sched_dep_min = (sched_dep_time %/% 100)*60+(sched_dep_time %% 100)) #&gt; # A tibble: 336,776 x 2 #&gt; dep_min sched_dep_min #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 317 315 #&gt; 2 333 329 #&gt; 3 342 340 #&gt; 4 344 345 #&gt; 5 354 360 #&gt; 6 354 358 #&gt; # ... with 336,770 more rows (2)比较 air_time 和arr_time–dep_time。你期望看到什么？实际又看到了什么？如何解决这个问题？ transmute(flights,air_time=air_time,t=arr_time-dep_time) #&gt; # A tibble: 336,776 x 2 #&gt; air_time t #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 227 313 #&gt; 2 227 317 #&gt; 3 160 381 #&gt; 4 183 460 #&gt; 5 116 258 #&gt; 6 150 186 #&gt; # ... with 336,770 more rows 因为arr_time,dep_time的格式都是HMM或者HHMM，air_time格式是分钟，所以前者直接相减是不会等于后者。一种方法把它们都转换成分钟。 flights%&gt;% transmute(air_time, arr_min = (arr_time %/% 100)*60+(arr_time %% 100), dep_min = (dep_time %/% 100)*60+(dep_time %% 100), t_min = arr_min-dep_min ) #&gt; # A tibble: 336,776 x 4 #&gt; air_time arr_min dep_min t_min #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 227 510 317 193 #&gt; 2 227 530 333 197 #&gt; 3 160 563 342 221 #&gt; 4 183 604 344 260 #&gt; 5 116 492 354 138 #&gt; 6 150 460 354 106 #&gt; # ... with 336,770 more rows 本以为air_time会与t_min相等，但是并不是…大于小于都有，这就很奇怪了，特别是air_time大于t_min这是啥意思… update:因为出发和到达时间都是当地时间，所以可能不同。可以将时间转为标准时间再计算。 (4)使用排秩函数找出 10 个延误时间最长的航班。如何处理名次相同的情况？仔细阅读 min_rank() 的帮助文件。 flights%&gt;% mutate(rank=min_rank(desc(arr_delay)))%&gt;% filter(rank&lt;=10)%&gt;% arrange(rank) #&gt; # A tibble: 10 x 20 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; # ... with 4 more rows, and 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, rank &lt;int&gt; (5)1:3 + 1:10会返回什么？为什么？ 1:3+1:10 #&gt; Warning in 1:3 + 1:10: 长的对象长度不是短的对象长度的整倍数 #&gt; [1] 2 4 6 5 7 9 8 10 12 11 相当于这样，长度不一样的向量运算时，短向量会“广播”： c(1:3,1:3,1:3,1)+1:10 #&gt; [1] 2 4 6 5 7 9 8 10 12 11 (6)R提供了哪些三角函数？ 利用 ?Trig 可以得到。 5.6 使用summarize()进行分组摘要 not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) 5.6.1 使用管道组合多种操作 x %&gt;% f(y)会转换成f(x,y)，依此类推。 在RStudio中管道%&gt;%的默认快捷键是Ctrl+Shift+M 5.6.2 练习 (1)通过头脑风暴，至少找出5种方法来确定一组航班的典型延误特征。思考以下场景。 • 一架航班 50% 的时间会提前 15 分钟，50% 的时间会延误 15 分钟。 • 一架航班总是会延误 10 分钟。 • 一架航班 50% 的时间会提前 30 分钟，50% 的时间会延误 30 分钟。 • 一架航班 99% 的时间会准时，1% 的时间会延误 2 个小时。 哪一种更重要：到达延误还是出发延误？ 那当然是到达延误更重要。 (2)找出另外一种方法，这种方法要可以给出与 not_cancelled %&gt;% count(dest)和not_cancelled %&gt;% count(tailnum, wt = distance)同样的输出（不能使用 count()）。 not_cancelled %&gt;% count(dest) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 264 #&gt; 3 ALB 418 #&gt; 4 ANC 8 #&gt; 5 ATL 16837 #&gt; 6 AUS 2411 #&gt; # ... with 98 more rows not_cancelled %&gt;% group_by(dest) %&gt;% summarise(n=n()) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 264 #&gt; 3 ALB 418 #&gt; 4 ANC 8 #&gt; 5 ATL 16837 #&gt; 6 AUS 2411 #&gt; # ... with 98 more rows not_cancelled %&gt;% count(tailnum, wt = distance) #&gt; # A tibble: 4,037 x 2 #&gt; tailnum n #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 D942DN 3418 #&gt; 2 N0EGMQ 239143 #&gt; 3 N10156 109664 #&gt; 4 N102UW 25722 #&gt; 5 N103US 24619 #&gt; 6 N104UW 24616 #&gt; # ... with 4,031 more rows not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise(n=sum(distance)) #&gt; # A tibble: 4,037 x 2 #&gt; tailnum n #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 D942DN 3418 #&gt; 2 N0EGMQ 239143 #&gt; 3 N10156 109664 #&gt; 4 N102UW 25722 #&gt; 5 N103US 24619 #&gt; 6 N104UW 24616 #&gt; # ... with 4,031 more rows (3)我们对已取消航班的定义(is.na(dep_delay))|(is.na(arr_delay))稍有欠佳。为什么？哪一列才是最重要的？ 我觉得，dep_time（出发时间）最重要，出发时间缺失明确表示航班取消。 (4)查看每天取消的航班数量。其中存在模式吗？已取消航班的比例与平均延误时间有关 系吗？ flights %&gt;% group_by(year,month,day) %&gt;% summarise(scale = mean(is.na(dep_time)), delay = mean(arr_delay,na.rm = T)) %&gt;% filter(scale&lt;0.5) %&gt;% # 去除两个离群点 ggplot(mapping = aes(x=scale,y=delay)) + geom_point()+ geom_smooth() 可以看到，已取消航班的比例升高，平均延误时间先较快增加随之变缓。 (5)哪个航空公司的延误情况最严重？挑战：你能否分清这是由于糟糕的机场设备，还是航空公司的问题？为什么能？为什么不能？（提示：考虑一下 flights %&gt;% group_by(carrier, dest) %&gt;% summarize(n())。） 不太明白…占个坑先。 (6)计算每架飞机在第一次延误超过1小时前的飞行次数。 有比较麻烦的做法… (7)count()函数中的sort参数的作用是什么？何时应该使用这个参数？ 没设置之前是这样的： not_cancelled %&gt;% count(dest) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 264 #&gt; 3 ALB 418 #&gt; 4 ANC 8 #&gt; 5 ATL 16837 #&gt; 6 AUS 2411 #&gt; # ... with 98 more rows 设置之后： not_cancelled %&gt;% count(dest,sort = T) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ATL 16837 #&gt; 2 ORD 16566 #&gt; 3 LAX 16026 #&gt; 4 BOS 15022 #&gt; 5 MCO 13967 #&gt; 6 CLT 13674 #&gt; # ... with 98 more rows 返回数据框的行会按照计数的大小进行降序排序。 5.7 分组新变量（和筛选器） 将分组与与mutate()和filter()函数结合。 5.7.1 练习 (2)哪一架飞机（用机尾编号来识别，tailnum）具有最差的准点记录？ flights %&gt;% group_by(tailnum) %&gt;% transmute(delay = mean(arr_delay,na.rm = T)) %&gt;% arrange(desc(delay)) #&gt; # A tibble: 336,776 x 2 #&gt; # Groups: tailnum [4,044] #&gt; tailnum delay #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 N844MH 320 #&gt; 2 N911DA 294 #&gt; 3 N922EV 276 #&gt; 4 N587NW 264 #&gt; 5 N851NW 219 #&gt; 6 N928DN 201 #&gt; # ... with 336,770 more rows (3)如果想要尽量避免航班延误，那么应该在一天中的哪个时间搭乘飞机？ 假如从纽约出发，不妨以每辆航班计划出发的时间小时作分组，然后统计该小时内航班延误数量。 not_cancelled %&gt;% mutate(sched_dep_hour = sched_dep_time %/% 100) %&gt;% group_by(sched_dep_hour) %&gt;% summarise(n=sum(dep_delay&gt;0)) %&gt;% ggplot(mapping = aes(x=sched_dep_hour,y=n))+ geom_line()+ geom_point() #&gt; `summarise()` ungrouping output (override with `.groups` argument) (4)计算每个目的地的延误总时间的分钟数，以及每架航班到每个目的地的延误时间比例。 not_cancelled %&gt;% group_by(dest) %&gt;% mutate(destsum = sum(arr_delay)) %&gt;% group_by(dest,tailnum) %&gt;% mutate(tailnumsum = sum(arr_delay)) %&gt;% mutate(delayscale = tailnumsum/destsum) %&gt;% select(dest,destsum,tailnum,tailnumsum,delayscale) %&gt;% arrange(dest) #&gt; # A tibble: 327,346 x 5 #&gt; # Groups: dest, tailnum [44,173] #&gt; dest destsum tailnum tailnumsum delayscale #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 ABQ 1113 N554JB -98 -0.0881 #&gt; 2 ABQ 1113 N607JB 97 0.0872 #&gt; 3 ABQ 1113 N591JB 12 0.0108 #&gt; 4 ABQ 1113 N662JB -40 -0.0359 #&gt; 5 ABQ 1113 N580JB 9 0.00809 #&gt; 6 ABQ 1113 N507JB 8 0.00719 #&gt; # ... with 327,340 more rows 就不区分延误时间的正负了。 (5)延误通常是由临时原因造成的：即使最初引起延误的问题已经解决，但因为要让前面的航班先起飞，所以后面的航班也会延误。使用lag()函数探究一架航班延误与前一架航班延误之间的关系。 探究一下前一架航班出发延误与后一架航班出发延误时间上的关系： 没弄明白航班的含义，先待续。 (6)查看每个目的地。你能否发现有些航班的速度快得可疑？（也就是说，这些航班的数据可能是错误的。）计算出到目的地的最短航线的飞行时间。哪架航班在空中的延误时间 最长？ not_cancelled %&gt;% mutate(speed = distance/air_time) %&gt;% select(tailnum,speed) %&gt;% arrange(desc(speed)) #&gt; # A tibble: 327,346 x 2 #&gt; tailnum speed #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 N666DN 11.7 #&gt; 2 N17196 10.8 #&gt; 3 N14568 10.8 #&gt; 4 N12567 10.7 #&gt; 5 N956DL 9.86 #&gt; 6 N3768 9.4 #&gt; # ... with 327,340 more rows "],["exploratory-data-analysis.html", "6 Exploratory Data Analysis 6.1 两类问题 6.2 一些tips 6.3 练习", " 6 Exploratory Data Analysis 探索性数据分析（EDA）是一个天马行空的不断迭代循环的思考过程，主要作用： 对数据提出问题 。 对数据进行可视化、转换和建模，进而找出问题的答案。 使用上一个步骤的结果来精炼问题，并提出新问题。 6.1 两类问题 对于数据，我们可以粗略地提出两大类问题： 变量本身会发生何种变动？ 不同变量之间会发生何种相关变动？ 6.2 一些tips 使用带有异常值和不带异常值的数据分别进行分析，是一种良好的做法。如果两次分析的 结果差别不大，而你又无法说明为什么会有异常值，那么完全可以用缺失值替代异常值， 然后继续进行分析。但如果两次分析的结果有显著差别，那么你就不能在没有正当理由的 情况下丢弃它们。你需要弄清出现异常值的原因（如数据输入错误），并在文章中说明丢弃它们的理由。 6.3 练习 6.3.1 3-变动 (1)研究 x、y 和 z 变量在diamonds数据集中的分布。你能发现什么？思考一下，对于一条钻石数据，如何确定表示长、宽和高的变量？ 利用直方图探究连续变量的变动： diamonds %&gt;% ggplot()+ geom_freqpoly(aes(x), binwidth = 0.5,color=&quot;black&quot;)+ geom_freqpoly(aes(y), binwidth = 0.5,color=&quot;red&quot;)+ geom_freqpoly(aes(z), binwidth = 0.5,color=&quot;blue&quot;) 可以看到，x（长）和y（宽）变量在数据集中的分布高度一致，它们与z（高）变量的分布形状类似。 (2)研究price的分布，你能发现不寻常或令人惊奇的事情吗？（提示：仔细考虑一下binwidth参数，并确定试验了足够多的取值。） 利用直方图探究连续变量的变动，多次调整值发现： diamonds %&gt;% ggplot()+ geom_histogram(aes(price),binwidth = 50)+ coord_cartesian(xlim = c(1450,1600)) 在1475-1525区间中是没有数据的，好像是有点奇怪… (3)0.99克拉的钻石有多少？1克拉的钻石有多少？造成这种区别的原因是什么？ diamonds %&gt;% filter(between(carat,0.99,1.01)) %&gt;% count(carat) #&gt; # A tibble: 3 x 2 #&gt; carat n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 0.99 23 #&gt; 2 1 1558 #&gt; 3 1.01 2242 估计大多数0.99克拉的钻石都会被当作1克拉对外宣称…就像一些人身高168的说自己170一样… 6.3.2 4-缺失值 (1)直方图如何处理缺失值？条形图如何处理缺失值？为什么会有这种区别？ 参考https://jrnold.github.io/r4ds-exercise-solutions/exploratory-data-analysis.html#exercise-7.4.1 diamonds2 &lt;- diamonds %&gt;% mutate(y = ifelse(y &lt; 3 | y &gt; 20, NA, y)) ggplot(diamonds2, aes(x = y)) + geom_histogram() #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. #&gt; Warning: Removed 9 rows containing non-finite values (stat_bin). diamonds %&gt;% mutate(cut = if_else(runif(n()) &lt; 0.1, NA_character_, as.character(cut))) %&gt;% ggplot() + geom_bar(mapping = aes(x = cut)) 直方图会丢弃NA值，条形图会把NA值作为一个取值。 (2)na.rm = TRUE在mean()和sum()函数中的作用是什么？ a &lt;- c(1:5,NA,NA) sum(a) #&gt; [1] NA sum(a,na.rm = T) #&gt; [1] 15 mean(a) #&gt; [1] NA mean(a,na.rm = T) #&gt; [1] 3 求非NA值的和以及求非NA值的均值（分母为非NA值的个数）。 "],["tibbles.html", "7 Tibbles 7.1 准备工作 7.2 创建tibble 7.3 对比tibble与data.frame 7.4 与旧代码进行交互 7.5 练习", " 7 Tibbles 7.1 准备工作 类似于data.frame的tibble。 library(tidyverse) 7.2 创建tibble 7.2.1 导图 7.2.2 实践 首先，iris数据集是data.frame而不是tibble。 is.data.frame(iris) #&gt; [1] TRUE is_tibble(iris) #&gt; [1] FALSE 利用tidyverse函数得到tibble iris1 &lt;- iris %&gt;% filter(Sepal.Width&gt;3) is_tibble(iris1) #&gt; [1] FALSE 实践失败了…利用tidyverse函数，传入数据框，处理之后仍然是数据框。 利用as_tibble创建tibble iris_tibble &lt;- as_tibble(iris) is_tibble(iris_tibble) #&gt; [1] TRUE 使用向量创建 x &lt;- c(1,2,3) y &lt;- 1 z &lt;- x+y a &lt;- tibble(x,y,z) str(a) #&gt; tibble [3 x 3] (S3: tbl_df/tbl/data.frame) #&gt; $ x: num [1:3] 1 2 3 #&gt; $ y: num [1:3] 1 1 1 #&gt; $ z: num [1:3] 2 3 4 使用tribble创建 a &lt;- tribble( ~x,~y,~z, &quot;a&quot;,1,1.1, &quot;b&quot;,2,0.5 ) str(a) #&gt; tibble [2 x 3] (S3: tbl_df/tbl/data.frame) #&gt; $ x: chr [1:2] &quot;a&quot; &quot;b&quot; #&gt; $ y: num [1:2] 1 2 #&gt; $ z: num [1:2] 1.1 0.5 这个的语法比较新鲜。 7.3 对比tibble与data.frame 打印print：tibble默认只显示前 10 行结果，并且列也是适合屏幕的，还会打印出列的类型。可以通过print的参数或者option修改默认设置。 取子集：tibble不能进行部分匹配，如果想要访问的列不存在，会生成一条警告信息。 7.4 与旧代码进行交互 使用as.data.frame()可以将tible转换为data.frame。 7.5 练习 (2)对比 data.frame和等价的tibble上进行的以下操作。有何区别？为什么默认的数据框操作会让人感到沮丧？ df &lt;- data.frame(abc = 1, xyz = &quot;a&quot;) df$x #&gt; [1] a #&gt; Levels: a df[, &quot;xyz&quot;] #&gt; [1] a #&gt; Levels: a df[, c(&quot;abc&quot;, &quot;xyz&quot;)] #&gt; abc xyz #&gt; 1 1 a df &lt;- as_tibble(df) df$x #&gt; Warning: Unknown or uninitialised column: `x`. #&gt; NULL df[, &quot;xyz&quot;] #&gt; # A tibble: 1 x 1 #&gt; xyz #&gt; &lt;fct&gt; #&gt; 1 a df[, c(&quot;abc&quot;, &quot;xyz&quot;)] #&gt; # A tibble: 1 x 2 #&gt; abc xyz #&gt; &lt;dbl&gt; &lt;fct&gt; #&gt; 1 1 a 区别：tibble不能进行部分匹配，而data.frame可以。并且，data.frame在取一列的时候返回的是向量而不是data.frame，当列名是一个变量时不好处理（你不知道返回的是向量还是data.frame），而tibble则会一致地返回tibble。 "],["data-import.html", "8 Data import 8.1 简介 8.2 入门 8.3 解析向量 8.4 解析文件 8.5 写入文件 8.6 练习", " 8 Data import 8.1 简介 学习利用readr包将纯文本格式的矩形文件读入 R。 library(tidyverse) 8.2 入门 readr有很多函数提供类似的使用方法实现对不同格式平面文件的读入，下面以read_csv函数为例学习这些函数一般的用法。 read_csv常用参数： 8.3 解析向量 我们先学习parse_*()函数族，它们接收一个字符串，然后返回一个特定数据类型的向量。 各函数的用法大致一样，第一个参数是需要解析的字符向量，na参数设定了哪些字符串应该当作缺失值来处理。解析失败的值在输出中是以缺失值的形式存在的。 各函数的作用大致如下： 8.4 解析文件 8.4.1 策略 readr使用一种启发式过程来确定每列的类型：先读取文件的前1000行，使用guess_parser()函数返回readr最可信的猜测，接着parse_guess()函数使用这个猜测来解析列。 8.4.2 问题 按照上面的策略来进行当然不可能万无一失。可能遇到的问题： 前 1000 行可能是一种特殊情况，readr猜测出的类型不足以代表整个文件。 列中可能含有大量缺失值。 每个parse_xyz()函数都有一个对应的col_xyz()函数。如果数据已经保存在R的字符向量中那么你可以使用parse_xyz()；如果想要告诉readr如何加载数据，则应该使用col_xyz()。 我们强烈建议你总是提供col_types参数，从readr打印出的输出中可以知道它的值。这可以确保数据导入脚本的一致性，并可以重复使用。如果不提供这个参数，而是依赖猜测的类型，那么当数据发生变化时，readr会继续读入数据。如果想要严格解析，可以使用stop_for_problems()函数：当出现任何解析问题时，它会抛出一个错误，并终止脚本。 8.4.3 其他策略 对于上面的问题，我们需要其他的策略： 设置guess_max读多几行数据 将所有列都作为字符向量读入，再结合type_convert()函数 如果正在读取一个非常大的文件，那么你应该将n_max设置为一个较小的数，比如10 000或者100 000。这可以让你在解决常见问题时加快重复试验的过程。 如果遇到严重的解析问题，有时使用read_lines()函数按行读入字符向量会更容易，甚至可以使用read_file()函数读入一个长度为1的字符向量。接着你可以使用后面将学到的字符串解析技能来解析各种各样的数据形式。 后两个策略暂时不太明白… 8.5 写入文件 8.6 练习 （1）有时CSV文件中的字符串会包含逗号。为了防止引发问题，需要用引号（如 \" 或 ’）将逗号围起来。按照惯例，read_csv()默认引号为\"，如果想要改变默认值，就要转而使用read_delim()函数。要想将以下文本读入一个数据框，需要设定哪些参数？ x &lt;- &quot;x,y\\n1,&#39;a,b&#39;&quot; read_csv(x,quote = &quot;&#39;&quot;) #&gt; # A tibble: 1 x 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 a,b 通过设置quote参数指定引号。 （2）找出以下每个行内 CSV 文件中的错误。如果运行代码，会发生什么情况？ read_csv(&quot;a,b\\n1,2,3\\n4,5,6&quot;) #&gt; Warning: 2 parsing failures. #&gt; row col expected actual file #&gt; 1 -- 2 columns 3 columns literal data #&gt; 2 -- 2 columns 3 columns literal data #&gt; # A tibble: 2 x 2 #&gt; a b #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2 #&gt; 2 4 5 read_csv(&quot;a,b,c\\n1,2\\n1,2,3,4&quot;) #&gt; Warning: 2 parsing failures. #&gt; row col expected actual file #&gt; 1 -- 3 columns 2 columns literal data #&gt; 2 -- 3 columns 4 columns literal data #&gt; # A tibble: 2 x 3 #&gt; a b c #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 2 NA #&gt; 2 1 2 3 列数不匹配，不是矩形数据。read_csv以第一列列数识别为文件列数，后面的数据列数不够部为NA，超过的截断。 x &lt;- &quot;a,b\\n\\&quot;1&quot; cat(x) #&gt; a,b #&gt; &quot;1 read_csv(x) #&gt; Warning: 2 parsing failures. #&gt; row col expected actual file #&gt; 1 a closing quote at end of file literal data #&gt; 1 -- 2 columns 1 columns literal data #&gt; # A tibble: 1 x 2 #&gt; a b #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 &lt;NA&gt; 估计是把\"1识别为整数1。 read_csv(&quot;a,b\\n1,2\\na,b&quot;) #&gt; # A tibble: 2 x 2 #&gt; a b #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2 #&gt; 2 a b read_csv(&quot;a;b\\n1;3&quot;) #&gt; # A tibble: 1 x 1 #&gt; `a;b` #&gt; &lt;chr&gt; #&gt; 1 1;3 将a;b与1;3识别为字符串了。 "],["tidy-data.html", "9 Tidy data 9.1 整齐的数据 9.2 数据的常见问题与整理方法 9.3 缺失值 9.4 练习", " 9 Tidy data 学习tidyr包，用于整理（整齐）数据。 library(tidyverse) 9.1 整齐的数据 想要整理数据，就得先知道我们的目标，即所谓“整齐的数据（tidy data）”指的是怎样的数据。 类似于数据库关系数据理论的1NF，整齐的数据需满足： 每个变量必须有自己的列 每个观察值必须有自己的一行 每个值都必须有自己的单元格 在我们tidyverse的工具下，应当做到： 将每个数据集放在一个tibble中 将每个变量放在一列中 整齐数据的优势主要有两个：得到一致性的数据结构、使R的矢量化运算发挥作用。 9.2 数据的常见问题与整理方法 9.3 缺失值 一个值可能会以两种方式丢失：显示与隐式。 An explicit missing value is the presence of an absence; an implicit missing value is the absence of a presence. 处理缺失值的几种方法： 不同的数据表示使隐式缺失值值显式化，或者可以设置隐式转换显式缺失值 显式显示缺失值：complete() fill()：将缺失值替换为最近的非缺失值 9.4 练习 （1）What would happen if you widen this table? Why? How could you add a new column to uniquely identify each value? people &lt;- tribble( ~name, ~key, ~value, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;age&quot;, 45, &quot;Phillip Woods&quot;, &quot;height&quot;, 186, &quot;Phillip Woods&quot;, &quot;age&quot;, 50, &quot;Jessica Cordero&quot;, &quot;age&quot;, 37, &quot;Jessica Cordero&quot;, &quot;height&quot;, 156 ) # name与key不能确定value people %&gt;% pivot_wider(names_from=&quot;key&quot;,values_from = &quot;value&quot;) #&gt; Warning: Values are not uniquely identified; output will contain list-cols. #&gt; * Use `values_fn = list` to suppress this warning. #&gt; * Use `values_fn = length` to identify where the duplicates arise #&gt; * Use `values_fn = {summary_fun}` to summarise duplicates #&gt; # A tibble: 2 x 3 #&gt; name age height #&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 Phillip Woods &lt;dbl [2]&gt; &lt;dbl [1]&gt; #&gt; 2 Jessica Cordero &lt;dbl [1]&gt; &lt;dbl [1]&gt; # 添加新列 people %&gt;% group_by(name,key) %&gt;% mutate(no = row_number()) %&gt;% pivot_wider(names_from = &quot;name&quot;,values_from=&quot;value&quot;) #&gt; # A tibble: 3 x 4 #&gt; # Groups: key [2] #&gt; key no `Phillip Woods` `Jessica Cordero` #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 age 1 45 37 #&gt; 2 height 1 186 156 #&gt; 3 age 2 50 NA （2）Tidy the simple tibble below. Do you need to make it wider or longer? What are the variables? preg &lt;- tribble( ~pregnant, ~male, ~female, &quot;yes&quot;, NA, 10, &quot;no&quot;, 20, 12 ) # longer preg %&gt;% pivot_longer(cols = c(&quot;male&quot;,&quot;female&quot;), names_to = &quot;sex&quot;, values_drop_na=T) %&gt;% # 去缺失值（怀孕，男） mutate( female = (sex==&quot;female&quot;), pregnant = (pregnant==&quot;yes&quot;) # 受启发，改为逻辑变量 ) %&gt;% select(female,pregnant,value) #&gt; # A tibble: 3 x 3 #&gt; female pregnant value #&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;dbl&gt; #&gt; 1 TRUE TRUE 10 #&gt; 2 FALSE FALSE 20 #&gt; 3 TRUE FALSE 12 "],["relational-data.html", "10 Relational data 10.1 键 10.2 处理关系数据的三种操作 10.3 练习", " 10 Relational data 学习利用dplyr中的函数处理关系数据，其实也就是实现SQL里边的一些内容。 library(tidyverse) library(nycflights13) 10.1 键 类似于数据库的定义，不再赘述。 关于如何验证表的主键，一种验证方法是对主键进行count()操作，然后查看是否有n大于1的记录，即看看是否违背唯一确定的性质： planes %&gt;% count(tailnum) %&gt;% filter(n&gt;1) #&gt; # A tibble: 0 x 2 #&gt; # ... with 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt; 关于如何建立代理键，可以利用mutate与row_number(): x &lt;- tribble( ~a,~b, 1,2, 1,3, 2,3 ) (x %&gt;% mutate(key=row_number()) %&gt;% select(key,everything())) #&gt; # A tibble: 3 x 3 #&gt; key a b #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 2 #&gt; 2 2 1 3 #&gt; 3 3 2 3 10.2 处理关系数据的三种操作 10.2.1 定义键列 通过上述函数的参数by来设置。 默认值by = NULL，自然连接。 字符向量by = \"x\"。这种方式与自然连接很相似，但只使用指定的公共变量。 命名字符向量by = c(\"a\" = \"b\")。这种方式会匹配x表中的a变量和y表中的b变量。输出结果中使用的是x表中的变量。适用于含义一样但名字不同的变量之间连接。 10.2.2 连接中的问题 首先，需要找出每个表中可以作为主键的变量。一般应该基于对数据的理解来确定主键，而不是凭经验寻找能作为唯一标识符的变量组合。从含义出发！ 确保主键中的每个变量都没有缺失值。（实体完整性…） 检查外键是否与另一张表的主键相匹配。最好的方法是使用anti_join()，由于数据录入错误，外键和主键不匹配的情况很常见。解决这种问题通常需要大量工作。 10.3 练习 （1）将起点机场和终点机场的位置信息（即lat和lon）添加到flights中。 先去掉airports中多余的变量，再两次左外连接： airport_locations &lt;- airports %&gt;% select(faa, lat, lon) flights %&gt;% select(year:day, hour, origin, dest) %&gt;% left_join( airport_locations, by = c(&quot;origin&quot; = &quot;faa&quot;) ) %&gt;% left_join( airport_locations, by = c(&quot;dest&quot; = &quot;faa&quot;) ) #&gt; # A tibble: 336,776 x 10 #&gt; year month day hour origin dest lat.x lon.x lat.y lon.y #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH 40.7 -74.2 30.0 -95.3 #&gt; 2 2013 1 1 5 LGA IAH 40.8 -73.9 30.0 -95.3 #&gt; 3 2013 1 1 5 JFK MIA 40.6 -73.8 25.8 -80.3 #&gt; 4 2013 1 1 5 JFK BQN 40.6 -73.8 NA NA #&gt; 5 2013 1 1 6 LGA ATL 40.8 -73.9 33.6 -84.4 #&gt; 6 2013 1 1 5 EWR ORD 40.7 -74.2 42.0 -87.9 #&gt; # ... with 336,770 more rows 为什么是左外连接而不是内连接？先看看内连接： flights %&gt;% select(year:day, hour, origin, dest) %&gt;% inner_join( airport_locations, by = c(&quot;origin&quot; = &quot;faa&quot;) ) %&gt;% inner_join( airport_locations, by = c(&quot;dest&quot; = &quot;faa&quot;) ) #&gt; # A tibble: 329,174 x 10 #&gt; year month day hour origin dest lat.x lon.x lat.y lon.y #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH 40.7 -74.2 30.0 -95.3 #&gt; 2 2013 1 1 5 LGA IAH 40.8 -73.9 30.0 -95.3 #&gt; 3 2013 1 1 5 JFK MIA 40.6 -73.8 25.8 -80.3 #&gt; 4 2013 1 1 6 LGA ATL 40.8 -73.9 33.6 -84.4 #&gt; 5 2013 1 1 5 EWR ORD 40.7 -74.2 42.0 -87.9 #&gt; 6 2013 1 1 6 EWR FLL 40.7 -74.2 26.1 -80.2 #&gt; # ... with 329,168 more rows 行数要少很多，说明有很多是没有匹配到的。 另一个问题，对于重复的变量lat,lot，连接时会默认添加.x,.y用于区分，可以使用参数suffix来修改。如： flights %&gt;% select(year:day, hour, origin, dest) %&gt;% left_join( airport_locations, by = c(&quot;origin&quot; = &quot;faa&quot;) ) %&gt;% left_join( airport_locations, by = c(&quot;dest&quot; = &quot;faa&quot;), suffix = c(&quot;_origin&quot;, &quot;_dest&quot;) ) #&gt; # A tibble: 336,776 x 10 #&gt; year month day hour origin dest lat_origin lon_origin lat_dest lon_dest #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 5 EWR IAH 40.7 -74.2 30.0 -95.3 #&gt; 2 2013 1 1 5 LGA IAH 40.8 -73.9 30.0 -95.3 #&gt; 3 2013 1 1 5 JFK MIA 40.6 -73.8 25.8 -80.3 #&gt; 4 2013 1 1 5 JFK BQN 40.6 -73.8 NA NA #&gt; 5 2013 1 1 6 LGA ATL 40.8 -73.9 33.6 -84.4 #&gt; 6 2013 1 1 5 EWR ORD 40.7 -74.2 42.0 -87.9 #&gt; # ... with 336,770 more rows "],["strings.html", "11 Strings 11.1 字符串基础 11.2 使用正则表达式进行模式匹配 11.3 工具 11.4 其他", " 11 Strings 学习stringr包去处理字符串，主要内容是正则表达式。 library(tidyverse) 11.1 字符串基础 关于丢弃长度为0的对象，稍微修改了一下原书的例子： name &lt;- &quot;Hadley&quot; time_of_day &lt;- &quot;morning&quot; birthday &lt;- FALSE str_c( &quot;Good &quot;, time_of_day, &quot; &quot;, name, if (birthday) &quot; and HAPPY BIRTHDAY&quot; else &quot;..&quot;, # 注意这里 &quot;.&quot; ) #&gt; [1] &quot;Good morning Hadley...&quot; 结合if语句使用非常好用。 11.2 使用正则表达式进行模式匹配 可以通过str_view()和str_view_all()函数来学习正则表达式 正则表达式的内容很多，下面只是简单把书上提高的内容列举一下： 11.2.1 练习 11.2.1.1 基础匹配 （1）解释一下为什么这些字符串不能匹配一个反斜杠\\：\"\\\"、\"\\\\\"、\"\\\\\\\"。 匹配一个反斜杠 \\ 的正则表达式为 \\\\ ，再转为字符串自然是\"\\\\\\\\\"。 而 # 这不是一个合法字符串，末尾缺一个&quot; writeLines(&quot;\\&quot;) # 这个字符串实际上是\\，不能匹配\\ writeLines(&quot;\\\\&quot;) #&gt; \\ # 非法字符串 writeLines(&quot;\\\\\\&quot;) （2）如何匹配字符序列 \"'\\ ？ # 先确定正则表达式为 &quot;&#39;\\\\ # 再确定字符串为 \\&quot;\\&#39;\\\\\\\\ writeLines(&quot;\\&quot;\\&#39;\\\\\\\\&quot;) #&gt; &quot;&#39;\\\\ # 最后验证一下 x &lt;- &quot;abc\\&quot;\\&#39;\\\\de&quot; writeLines(x) #&gt; abc&quot;&#39;\\de str_view(x, &quot;\\&quot;\\&#39;\\\\\\\\&quot;) （3）正则表达式\\..\\..\\..会匹配哪种模式？如何用字符串来表示这个正则表达式？ 会匹配“.+任意字符+.+任意字符+.+任意字符”。 # 字符串表达 x &lt;- &quot;\\\\..\\\\..\\\\..&quot; writeLines(x) #&gt; \\..\\..\\.. 11.2.1.2 锚点 （1）如何匹配字符串\"$^$\"？ # 先确定正则表达式为 \\$\\^\\$ # 再确定字符串 x &lt;- &quot;\\\\$\\\\^\\\\$&quot; writeLines(x) #&gt; \\$\\^\\$ # 尝试匹配 s &lt;- &quot;ab$^$cd&quot; writeLines(s) #&gt; ab$^$cd str_view(s,x) 更正：之前没有考虑到全字匹配。 # 先确定正则表达式为 ^\\$\\^\\$$ # 再确定字符串 x &lt;- &quot;^\\\\$\\\\^\\\\$$&quot; writeLines(x) #&gt; ^\\$\\^\\$$ # 尝试匹配 str_view(c(&quot;$^$&quot;, &quot;ab$^$sfas&quot;), &quot;^\\\\$\\\\^\\\\$$&quot;, match = TRUE) （2）给定stringr::words中的常用单词语料库，创建正则表达式以找出满足下列条件的所有单词。 # 以 y 开头的单词 x &lt;- &quot;^y&quot; str_view(stringr::words,x,match = T) # 以 x 结尾的单词 x &lt;- &quot;x$&quot; str_view(stringr::words,x,match = T) # 长度正好为 3 个字符的单词。 x &lt;- &quot;^...$&quot; str_subset(stringr::words,x) #&gt; [1] &quot;act&quot; &quot;add&quot; &quot;age&quot; &quot;ago&quot; &quot;air&quot; &quot;all&quot; &quot;and&quot; &quot;any&quot; &quot;arm&quot; &quot;art&quot; &quot;ask&quot; &quot;bad&quot; #&gt; [13] &quot;bag&quot; &quot;bar&quot; &quot;bed&quot; &quot;bet&quot; &quot;big&quot; &quot;bit&quot; &quot;box&quot; &quot;boy&quot; &quot;bus&quot; &quot;but&quot; &quot;buy&quot; &quot;can&quot; #&gt; [25] &quot;car&quot; &quot;cat&quot; &quot;cup&quot; &quot;cut&quot; &quot;dad&quot; &quot;day&quot; &quot;die&quot; &quot;dog&quot; &quot;dry&quot; &quot;due&quot; &quot;eat&quot; &quot;egg&quot; #&gt; [37] &quot;end&quot; &quot;eye&quot; &quot;far&quot; &quot;few&quot; &quot;fit&quot; &quot;fly&quot; &quot;for&quot; &quot;fun&quot; &quot;gas&quot; &quot;get&quot; &quot;god&quot; &quot;guy&quot; #&gt; [49] &quot;hit&quot; &quot;hot&quot; &quot;how&quot; &quot;job&quot; &quot;key&quot; &quot;kid&quot; &quot;lad&quot; &quot;law&quot; &quot;lay&quot; &quot;leg&quot; &quot;let&quot; &quot;lie&quot; #&gt; [61] &quot;lot&quot; &quot;low&quot; &quot;man&quot; &quot;may&quot; &quot;mrs&quot; &quot;new&quot; &quot;non&quot; &quot;not&quot; &quot;now&quot; &quot;odd&quot; &quot;off&quot; &quot;old&quot; #&gt; [73] &quot;one&quot; &quot;out&quot; &quot;own&quot; &quot;pay&quot; &quot;per&quot; &quot;put&quot; &quot;red&quot; &quot;rid&quot; &quot;run&quot; &quot;say&quot; &quot;see&quot; &quot;set&quot; #&gt; [85] &quot;sex&quot; &quot;she&quot; &quot;sir&quot; &quot;sit&quot; &quot;six&quot; &quot;son&quot; &quot;sun&quot; &quot;tax&quot; &quot;tea&quot; &quot;ten&quot; &quot;the&quot; &quot;tie&quot; #&gt; [97] &quot;too&quot; &quot;top&quot; &quot;try&quot; &quot;two&quot; &quot;use&quot; &quot;war&quot; &quot;way&quot; &quot;wee&quot; &quot;who&quot; &quot;why&quot; &quot;win&quot; &quot;yes&quot; #&gt; [109] &quot;yet&quot; &quot;you&quot; # 具有 7 个或更多字符的单词 x &lt;- &quot;^.......&quot; str_subset(stringr::words,x) #&gt; [1] &quot;absolute&quot; &quot;account&quot; &quot;achieve&quot; &quot;address&quot; &quot;advertise&quot; #&gt; [6] &quot;afternoon&quot; &quot;against&quot; &quot;already&quot; &quot;alright&quot; &quot;although&quot; #&gt; [11] &quot;america&quot; &quot;another&quot; &quot;apparent&quot; &quot;appoint&quot; &quot;approach&quot; #&gt; [16] &quot;appropriate&quot; &quot;arrange&quot; &quot;associate&quot; &quot;authority&quot; &quot;available&quot; #&gt; [21] &quot;balance&quot; &quot;because&quot; &quot;believe&quot; &quot;benefit&quot; &quot;between&quot; #&gt; [26] &quot;brilliant&quot; &quot;britain&quot; &quot;brother&quot; &quot;business&quot; &quot;certain&quot; #&gt; [31] &quot;chairman&quot; &quot;character&quot; &quot;Christmas&quot; &quot;colleague&quot; &quot;collect&quot; #&gt; [36] &quot;college&quot; &quot;comment&quot; &quot;committee&quot; &quot;community&quot; &quot;company&quot; #&gt; [41] &quot;compare&quot; &quot;complete&quot; &quot;compute&quot; &quot;concern&quot; &quot;condition&quot; #&gt; [46] &quot;consider&quot; &quot;consult&quot; &quot;contact&quot; &quot;continue&quot; &quot;contract&quot; #&gt; [51] &quot;control&quot; &quot;converse&quot; &quot;correct&quot; &quot;council&quot; &quot;country&quot; #&gt; [56] &quot;current&quot; &quot;decision&quot; &quot;definite&quot; &quot;department&quot; &quot;describe&quot; #&gt; [61] &quot;develop&quot; &quot;difference&quot; &quot;difficult&quot; &quot;discuss&quot; &quot;district&quot; #&gt; [66] &quot;document&quot; &quot;economy&quot; &quot;educate&quot; &quot;electric&quot; &quot;encourage&quot; #&gt; [71] &quot;english&quot; &quot;environment&quot; &quot;especial&quot; &quot;evening&quot; &quot;evidence&quot; #&gt; [76] &quot;example&quot; &quot;exercise&quot; &quot;expense&quot; &quot;experience&quot; &quot;explain&quot; #&gt; [81] &quot;express&quot; &quot;finance&quot; &quot;fortune&quot; &quot;forward&quot; &quot;function&quot; #&gt; [86] &quot;further&quot; &quot;general&quot; &quot;germany&quot; &quot;goodbye&quot; &quot;history&quot; #&gt; [91] &quot;holiday&quot; &quot;hospital&quot; &quot;however&quot; &quot;hundred&quot; &quot;husband&quot; #&gt; [96] &quot;identify&quot; &quot;imagine&quot; &quot;important&quot; &quot;improve&quot; &quot;include&quot; #&gt; [101] &quot;increase&quot; &quot;individual&quot; &quot;industry&quot; &quot;instead&quot; &quot;interest&quot; #&gt; [106] &quot;introduce&quot; &quot;involve&quot; &quot;kitchen&quot; &quot;language&quot; &quot;machine&quot; #&gt; [111] &quot;meaning&quot; &quot;measure&quot; &quot;mention&quot; &quot;million&quot; &quot;minister&quot; #&gt; [116] &quot;morning&quot; &quot;necessary&quot; &quot;obvious&quot; &quot;occasion&quot; &quot;operate&quot; #&gt; [121] &quot;opportunity&quot; &quot;organize&quot; &quot;original&quot; &quot;otherwise&quot; &quot;paragraph&quot; #&gt; [126] &quot;particular&quot; &quot;pension&quot; &quot;percent&quot; &quot;perfect&quot; &quot;perhaps&quot; #&gt; [131] &quot;photograph&quot; &quot;picture&quot; &quot;politic&quot; &quot;position&quot; &quot;positive&quot; #&gt; [136] &quot;possible&quot; &quot;practise&quot; &quot;prepare&quot; &quot;present&quot; &quot;pressure&quot; #&gt; [141] &quot;presume&quot; &quot;previous&quot; &quot;private&quot; &quot;probable&quot; &quot;problem&quot; #&gt; [146] &quot;proceed&quot; &quot;process&quot; &quot;produce&quot; &quot;product&quot; &quot;programme&quot; #&gt; [151] &quot;project&quot; &quot;propose&quot; &quot;protect&quot; &quot;provide&quot; &quot;purpose&quot; #&gt; [156] &quot;quality&quot; &quot;quarter&quot; &quot;question&quot; &quot;realise&quot; &quot;receive&quot; #&gt; [161] &quot;recognize&quot; &quot;recommend&quot; &quot;relation&quot; &quot;remember&quot; &quot;represent&quot; #&gt; [166] &quot;require&quot; &quot;research&quot; &quot;resource&quot; &quot;respect&quot; &quot;responsible&quot; #&gt; [171] &quot;saturday&quot; &quot;science&quot; &quot;scotland&quot; &quot;secretary&quot; &quot;section&quot; #&gt; [176] &quot;separate&quot; &quot;serious&quot; &quot;service&quot; &quot;similar&quot; &quot;situate&quot; #&gt; [181] &quot;society&quot; &quot;special&quot; &quot;specific&quot; &quot;standard&quot; &quot;station&quot; #&gt; [186] &quot;straight&quot; &quot;strategy&quot; &quot;structure&quot; &quot;student&quot; &quot;subject&quot; #&gt; [191] &quot;succeed&quot; &quot;suggest&quot; &quot;support&quot; &quot;suppose&quot; &quot;surprise&quot; #&gt; [196] &quot;telephone&quot; &quot;television&quot; &quot;terrible&quot; &quot;therefore&quot; &quot;thirteen&quot; #&gt; [201] &quot;thousand&quot; &quot;through&quot; &quot;thursday&quot; &quot;together&quot; &quot;tomorrow&quot; #&gt; [206] &quot;tonight&quot; &quot;traffic&quot; &quot;transport&quot; &quot;trouble&quot; &quot;tuesday&quot; #&gt; [211] &quot;understand&quot; &quot;university&quot; &quot;various&quot; &quot;village&quot; &quot;wednesday&quot; #&gt; [216] &quot;welcome&quot; &quot;whether&quot; &quot;without&quot; &quot;yesterday&quot; 11.2.1.3 字符类与字符选项 （1）创建正则表达式来找出符合以下条件的所有单词。 # 以元音字母开头的单词 x &lt;- &quot;^[aeiou]&quot; # str_view(stringr::words,x,match = T) # 参考答案，结果太多，使用str_subset str_subset(stringr::words,x) #&gt; [1] &quot;a&quot; &quot;able&quot; &quot;about&quot; &quot;absolute&quot; &quot;accept&quot; #&gt; [6] &quot;account&quot; &quot;achieve&quot; &quot;across&quot; &quot;act&quot; &quot;active&quot; #&gt; [11] &quot;actual&quot; &quot;add&quot; &quot;address&quot; &quot;admit&quot; &quot;advertise&quot; #&gt; [16] &quot;affect&quot; &quot;afford&quot; &quot;after&quot; &quot;afternoon&quot; &quot;again&quot; #&gt; [21] &quot;against&quot; &quot;age&quot; &quot;agent&quot; &quot;ago&quot; &quot;agree&quot; #&gt; [26] &quot;air&quot; &quot;all&quot; &quot;allow&quot; &quot;almost&quot; &quot;along&quot; #&gt; [31] &quot;already&quot; &quot;alright&quot; &quot;also&quot; &quot;although&quot; &quot;always&quot; #&gt; [36] &quot;america&quot; &quot;amount&quot; &quot;and&quot; &quot;another&quot; &quot;answer&quot; #&gt; [41] &quot;any&quot; &quot;apart&quot; &quot;apparent&quot; &quot;appear&quot; &quot;apply&quot; #&gt; [46] &quot;appoint&quot; &quot;approach&quot; &quot;appropriate&quot; &quot;area&quot; &quot;argue&quot; #&gt; [51] &quot;arm&quot; &quot;around&quot; &quot;arrange&quot; &quot;art&quot; &quot;as&quot; #&gt; [56] &quot;ask&quot; &quot;associate&quot; &quot;assume&quot; &quot;at&quot; &quot;attend&quot; #&gt; [61] &quot;authority&quot; &quot;available&quot; &quot;aware&quot; &quot;away&quot; &quot;awful&quot; #&gt; [66] &quot;each&quot; &quot;early&quot; &quot;east&quot; &quot;easy&quot; &quot;eat&quot; #&gt; [71] &quot;economy&quot; &quot;educate&quot; &quot;effect&quot; &quot;egg&quot; &quot;eight&quot; #&gt; [76] &quot;either&quot; &quot;elect&quot; &quot;electric&quot; &quot;eleven&quot; &quot;else&quot; #&gt; [81] &quot;employ&quot; &quot;encourage&quot; &quot;end&quot; &quot;engine&quot; &quot;english&quot; #&gt; [86] &quot;enjoy&quot; &quot;enough&quot; &quot;enter&quot; &quot;environment&quot; &quot;equal&quot; #&gt; [91] &quot;especial&quot; &quot;europe&quot; &quot;even&quot; &quot;evening&quot; &quot;ever&quot; #&gt; [96] &quot;every&quot; &quot;evidence&quot; &quot;exact&quot; &quot;example&quot; &quot;except&quot; #&gt; [101] &quot;excuse&quot; &quot;exercise&quot; &quot;exist&quot; &quot;expect&quot; &quot;expense&quot; #&gt; [106] &quot;experience&quot; &quot;explain&quot; &quot;express&quot; &quot;extra&quot; &quot;eye&quot; #&gt; [111] &quot;idea&quot; &quot;identify&quot; &quot;if&quot; &quot;imagine&quot; &quot;important&quot; #&gt; [116] &quot;improve&quot; &quot;in&quot; &quot;include&quot; &quot;income&quot; &quot;increase&quot; #&gt; [121] &quot;indeed&quot; &quot;individual&quot; &quot;industry&quot; &quot;inform&quot; &quot;inside&quot; #&gt; [126] &quot;instead&quot; &quot;insure&quot; &quot;interest&quot; &quot;into&quot; &quot;introduce&quot; #&gt; [131] &quot;invest&quot; &quot;involve&quot; &quot;issue&quot; &quot;it&quot; &quot;item&quot; #&gt; [136] &quot;obvious&quot; &quot;occasion&quot; &quot;odd&quot; &quot;of&quot; &quot;off&quot; #&gt; [141] &quot;offer&quot; &quot;office&quot; &quot;often&quot; &quot;okay&quot; &quot;old&quot; #&gt; [146] &quot;on&quot; &quot;once&quot; &quot;one&quot; &quot;only&quot; &quot;open&quot; #&gt; [151] &quot;operate&quot; &quot;opportunity&quot; &quot;oppose&quot; &quot;or&quot; &quot;order&quot; #&gt; [156] &quot;organize&quot; &quot;original&quot; &quot;other&quot; &quot;otherwise&quot; &quot;ought&quot; #&gt; [161] &quot;out&quot; &quot;over&quot; &quot;own&quot; &quot;under&quot; &quot;understand&quot; #&gt; [166] &quot;union&quot; &quot;unit&quot; &quot;unite&quot; &quot;university&quot; &quot;unless&quot; #&gt; [171] &quot;until&quot; &quot;up&quot; &quot;upon&quot; &quot;use&quot; &quot;usual&quot; # 只包含辅音字母的单词 x &lt;- &quot;[aeiou]&quot; str_view(stringr::words,x,match = F) # match=F，只显示匹配不成功的单词 # 若使用str_subset，设置negate=TRUE # 以 ed 结尾，但不以 eed 结尾的单词 x &lt;- &quot;[^e]ed$&quot; str_view(stringr::words,x,match = T) # ADD:上面不会匹配到字符串&quot;ed&quot;，需要手动加入 # x &lt;- &quot;(^|[^e])ed$&quot; # 以 ing 或 ise 结尾的单词 x &lt;- &quot;ing|ise&quot; # 或者i(ng|se) str_view(stringr::words,x,match = T) （2）实际验证一下规则：i 总是在 e 前面，除非 i 前面有 c。 那就假设它们是挨在一起的了。 # 要匹配不符合规则的字符串，比如 # [^c]ei,^ei x &lt;- &quot;[^c]ei|^ei&quot; str_view(stringr::words,x,match = T) （3）q 后面总是跟着一个 u 吗？ x &lt;- &quot;q[^u]&quot; str_view(stringr::words,x,match = T) 在这个数据集中的确是这样子的。 11.2.1.4 重复 （3）创建正则表达式来找出满足以下条件的所有单词。 # 以 3 个辅音字母开头的单词 x &lt;- &quot;^[^aeiou]{3}&quot; str_subset(stringr::words,x) #&gt; [1] &quot;Christ&quot; &quot;Christmas&quot; &quot;dry&quot; &quot;fly&quot; &quot;mrs&quot; &quot;scheme&quot; #&gt; [7] &quot;school&quot; &quot;straight&quot; &quot;strategy&quot; &quot;street&quot; &quot;strike&quot; &quot;strong&quot; #&gt; [13] &quot;structure&quot; &quot;system&quot; &quot;three&quot; &quot;through&quot; &quot;throw&quot; &quot;try&quot; #&gt; [19] &quot;type&quot; &quot;why&quot; # 有连续 3 个或更多元音字母的单词 x &lt;- &quot;[aeiou]{3,}&quot; str_subset(stringr::words,x) #&gt; [1] &quot;beauty&quot; &quot;obvious&quot; &quot;previous&quot; &quot;quiet&quot; &quot;serious&quot; &quot;various&quot; # 有连续 2 个或更多元音—辅音配对的单词 x &lt;- &quot;([aeiou][^aeiou]){2,}&quot; str_subset(stringr::words,x) #&gt; [1] &quot;absolute&quot; &quot;agent&quot; &quot;along&quot; &quot;america&quot; &quot;another&quot; #&gt; [6] &quot;apart&quot; &quot;apparent&quot; &quot;authority&quot; &quot;available&quot; &quot;aware&quot; #&gt; [11] &quot;away&quot; &quot;balance&quot; &quot;basis&quot; &quot;become&quot; &quot;before&quot; #&gt; [16] &quot;begin&quot; &quot;behind&quot; &quot;benefit&quot; &quot;business&quot; &quot;character&quot; #&gt; [21] &quot;closes&quot; &quot;community&quot; &quot;consider&quot; &quot;cover&quot; &quot;debate&quot; #&gt; [26] &quot;decide&quot; &quot;decision&quot; &quot;definite&quot; &quot;department&quot; &quot;depend&quot; #&gt; [31] &quot;design&quot; &quot;develop&quot; &quot;difference&quot; &quot;difficult&quot; &quot;direct&quot; #&gt; [36] &quot;divide&quot; &quot;document&quot; &quot;during&quot; &quot;economy&quot; &quot;educate&quot; #&gt; [41] &quot;elect&quot; &quot;electric&quot; &quot;eleven&quot; &quot;encourage&quot; &quot;environment&quot; #&gt; [46] &quot;europe&quot; &quot;even&quot; &quot;evening&quot; &quot;ever&quot; &quot;every&quot; #&gt; [51] &quot;evidence&quot; &quot;exact&quot; &quot;example&quot; &quot;exercise&quot; &quot;exist&quot; #&gt; [56] &quot;family&quot; &quot;figure&quot; &quot;final&quot; &quot;finance&quot; &quot;finish&quot; #&gt; [61] &quot;friday&quot; &quot;future&quot; &quot;general&quot; &quot;govern&quot; &quot;holiday&quot; #&gt; [66] &quot;honest&quot; &quot;hospital&quot; &quot;however&quot; &quot;identify&quot; &quot;imagine&quot; #&gt; [71] &quot;individual&quot; &quot;interest&quot; &quot;introduce&quot; &quot;item&quot; &quot;jesus&quot; #&gt; [76] &quot;level&quot; &quot;likely&quot; &quot;limit&quot; &quot;local&quot; &quot;major&quot; #&gt; [81] &quot;manage&quot; &quot;meaning&quot; &quot;measure&quot; &quot;minister&quot; &quot;minus&quot; #&gt; [86] &quot;minute&quot; &quot;moment&quot; &quot;money&quot; &quot;music&quot; &quot;nature&quot; #&gt; [91] &quot;necessary&quot; &quot;never&quot; &quot;notice&quot; &quot;okay&quot; &quot;open&quot; #&gt; [96] &quot;operate&quot; &quot;opportunity&quot; &quot;organize&quot; &quot;original&quot; &quot;over&quot; #&gt; [101] &quot;paper&quot; &quot;paragraph&quot; &quot;parent&quot; &quot;particular&quot; &quot;photograph&quot; #&gt; [106] &quot;police&quot; &quot;policy&quot; &quot;politic&quot; &quot;position&quot; &quot;positive&quot; #&gt; [111] &quot;power&quot; &quot;prepare&quot; &quot;present&quot; &quot;presume&quot; &quot;private&quot; #&gt; [116] &quot;probable&quot; &quot;process&quot; &quot;produce&quot; &quot;product&quot; &quot;project&quot; #&gt; [121] &quot;proper&quot; &quot;propose&quot; &quot;protect&quot; &quot;provide&quot; &quot;quality&quot; #&gt; [126] &quot;realise&quot; &quot;reason&quot; &quot;recent&quot; &quot;recognize&quot; &quot;recommend&quot; #&gt; [131] &quot;record&quot; &quot;reduce&quot; &quot;refer&quot; &quot;regard&quot; &quot;relation&quot; #&gt; [136] &quot;remember&quot; &quot;report&quot; &quot;represent&quot; &quot;result&quot; &quot;return&quot; #&gt; [141] &quot;saturday&quot; &quot;second&quot; &quot;secretary&quot; &quot;secure&quot; &quot;separate&quot; #&gt; [146] &quot;seven&quot; &quot;similar&quot; &quot;specific&quot; &quot;strategy&quot; &quot;student&quot; #&gt; [151] &quot;stupid&quot; &quot;telephone&quot; &quot;television&quot; &quot;therefore&quot; &quot;thousand&quot; #&gt; [156] &quot;today&quot; &quot;together&quot; &quot;tomorrow&quot; &quot;tonight&quot; &quot;total&quot; #&gt; [161] &quot;toward&quot; &quot;travel&quot; &quot;unit&quot; &quot;unite&quot; &quot;university&quot; #&gt; [166] &quot;upon&quot; &quot;visit&quot; &quot;water&quot; &quot;woman&quot; 11.2.1.5 分组与回溯引用 （2）创建正则表达式来匹配出以下单词。 # 开头字母和结尾字母相同的单词 x &lt;- &quot;^(.).*\\\\1$&quot; str_subset(stringr::words,x) #&gt; [1] &quot;america&quot; &quot;area&quot; &quot;dad&quot; &quot;dead&quot; &quot;depend&quot; #&gt; [6] &quot;educate&quot; &quot;else&quot; &quot;encourage&quot; &quot;engine&quot; &quot;europe&quot; #&gt; [11] &quot;evidence&quot; &quot;example&quot; &quot;excuse&quot; &quot;exercise&quot; &quot;expense&quot; #&gt; [16] &quot;experience&quot; &quot;eye&quot; &quot;health&quot; &quot;high&quot; &quot;knock&quot; #&gt; [21] &quot;level&quot; &quot;local&quot; &quot;nation&quot; &quot;non&quot; &quot;rather&quot; #&gt; [26] &quot;refer&quot; &quot;remember&quot; &quot;serious&quot; &quot;stairs&quot; &quot;test&quot; #&gt; [31] &quot;tonight&quot; &quot;transport&quot; &quot;treat&quot; &quot;trust&quot; &quot;window&quot; #&gt; [36] &quot;yesterday&quot; # 更正：忽略只有一个字母的字符串 x &lt;- &quot;^(.)((.*\\\\1$)|$)&quot; str_subset(stringr::words,x) #&gt; [1] &quot;a&quot; &quot;america&quot; &quot;area&quot; &quot;dad&quot; &quot;dead&quot; #&gt; [6] &quot;depend&quot; &quot;educate&quot; &quot;else&quot; &quot;encourage&quot; &quot;engine&quot; #&gt; [11] &quot;europe&quot; &quot;evidence&quot; &quot;example&quot; &quot;excuse&quot; &quot;exercise&quot; #&gt; [16] &quot;expense&quot; &quot;experience&quot; &quot;eye&quot; &quot;health&quot; &quot;high&quot; #&gt; [21] &quot;knock&quot; &quot;level&quot; &quot;local&quot; &quot;nation&quot; &quot;non&quot; #&gt; [26] &quot;rather&quot; &quot;refer&quot; &quot;remember&quot; &quot;serious&quot; &quot;stairs&quot; #&gt; [31] &quot;test&quot; &quot;tonight&quot; &quot;transport&quot; &quot;treat&quot; &quot;trust&quot; #&gt; [36] &quot;window&quot; &quot;yesterday&quot; # 包含一对重复字母的单词（例如，church 中包含了重复的 ch）。 # 严谨一点，用[A-Za-z]代替. x &lt;- &quot;(..).*\\\\1&quot; str_subset(stringr::words,x) #&gt; [1] &quot;appropriate&quot; &quot;church&quot; &quot;condition&quot; &quot;decide&quot; &quot;environment&quot; #&gt; [6] &quot;london&quot; &quot;paragraph&quot; &quot;particular&quot; &quot;photograph&quot; &quot;prepare&quot; #&gt; [11] &quot;pressure&quot; &quot;remember&quot; &quot;represent&quot; &quot;require&quot; &quot;sense&quot; #&gt; [16] &quot;therefore&quot; &quot;understand&quot; &quot;whether&quot; # 包含一个至少重复 3 次的字母的单词（例如，eleven 中的 e 重复了 3 次） # 严谨一点，用[A-Za-z]代替. x &lt;- &quot;(.).*\\\\1.*\\\\1&quot; str_subset(stringr::words,x) #&gt; [1] &quot;appropriate&quot; &quot;available&quot; &quot;believe&quot; &quot;between&quot; &quot;business&quot; #&gt; [6] &quot;degree&quot; &quot;difference&quot; &quot;discuss&quot; &quot;eleven&quot; &quot;environment&quot; #&gt; [11] &quot;evidence&quot; &quot;exercise&quot; &quot;expense&quot; &quot;experience&quot; &quot;individual&quot; #&gt; [16] &quot;paragraph&quot; &quot;receive&quot; &quot;remember&quot; &quot;represent&quot; &quot;telephone&quot; #&gt; [21] &quot;therefore&quot; &quot;tomorrow&quot; 11.3 工具 利用正则匹配来解决实际问题 11.3.1 导图 11.3.2 关于匹配的一些注意 如果正则表达式过于复杂，则应该将其分解为几个更小的子表达式，将每个子表达式的匹配结果赋给一个变量，并使用逻辑运算组合起来。 匹配从来不会重叠。 很多stringr函数都是成对出现的：一个函数用于单个匹配，另一个函数用于全部匹配，后者会有后缀 _all。 11.3.3 boundary() boundary()可以通过字母(character)、行(line_break)、句子(sentence)和单词(word)边界来拆分字符串。 比如 x &lt;- &quot;This is a sentence. This is another sentence.&quot; str_view_all(x, boundary(&quot;word&quot;)) str_split(x,boundary(&quot;word&quot;)) #&gt; [[1]] #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; &quot;This&quot; &quot;is&quot; &quot;another&quot; #&gt; [8] &quot;sentence&quot; 11.3.3.1 疑问 有一点不太明白，boundary(\"word)如果是用于匹配词，那么再使用str_split拆分，剩下的不应该是“非词”部分吗？比如是用空格拆分，返回非空格部分： str_split(x,&quot; &quot;) #&gt; [[1]] #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence.&quot; &quot;This&quot; &quot;is&quot; #&gt; [7] &quot;another&quot; &quot;sentence.&quot; 但你要说它不是匹配词，用str_extract_all()函数却可以得到拆分结果： str_extract_all(x,boundary(&quot;word&quot;)) #&gt; [[1]] #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;sentence&quot; &quot;This&quot; &quot;is&quot; &quot;another&quot; #&gt; [8] &quot;sentence&quot; 可能这个函数重载了？挖个坑… 11.4 其他 "],["factors.html", "12 Factors 12.1 导图", " 12 Factors 学习forcats包去处理分类变量（因子）。 library(tidyverse) 12.1 导图 "]]
