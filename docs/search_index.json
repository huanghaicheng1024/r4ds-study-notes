[["index.html", "r4ds学习笔记 背景", " r4ds学习笔记 Huang 2020-10-27 背景 开始正式学习《R for data science》(https://r4ds.had.co.nz/) 2020-8-29 "],["intro.html", "1 Introduction", " 1 Introduction 这本书主要讲解的，是如何使用非常重要的数据科学工具，并给出了工具模型 其大致的含义如下： "],["explore-intro.html", "2 Introduction", " 2 Introduction 首先开始讲解的是数据探索这部分内容。 数据探索是一门艺术，它是审视数据、生成假设、假设检验的不断反复的过程。 "],["data-visualisation.html", "3 Data visualisation 3.1 Introduction 3.2 First steps 3.3 Aesthetic mappings 3.4 Common problems 3.5 Facets分面 3.6 几何对象 3.7 统计变换 3.8 位置调整 3.9 坐标系 3.10 图形分层语法", " 3 Data visualisation 3.1 Introduction 我们将要学习的第一套工具，ggplot2的程序包，用于绘图。 首先加载tidyverse library(tidyverse) 3.2 First steps 先绘制一个mpg数据框里边的引擎大小(displ)-燃油效率(hwy)散点图 ggplot(data = mpg)+ geom_point(mapping = aes(x = displ,y = hwy)) 可以看到，绘图的模板命令大致是 ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) ggplot(data = &lt;DATA&gt;) 这是在生成一个空白图层，指定数据。 &lt;GEOM_FUNCTION&gt;(mapping = aes(&lt;MAPPINGS&gt;)) 这是在空白图层上方继续加图层，比如前面的geom_point就是加上散点图图层。mapping是映射，是将数据框的属性映射成图形属性，常见的我们还用aes()，这是将将数据框的属性映射成x,y轴变量。 3.2.1 Exercises 运行ggplot(data = mpg)，你会看到什么？ ggplot(data = mpg) 显然，是一个空白的图层。 数据集mpg中有多少行？多少列？ str(mpg) #&gt; tibble [234 x 11] (S3: tbl_df/tbl/data.frame) #&gt; $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... #&gt; $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... #&gt; $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... #&gt; $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... #&gt; $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... #&gt; $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... #&gt; $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... #&gt; $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... #&gt; $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... #&gt; $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... #&gt; $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... 利用str函数，可以得到数据集mpg中有234行11列。 变量drv的意义是什么？使用?mpg命令阅读帮助文件以找出答案。 #&gt; starting httpd help server ... done 通过阅读帮助文档可以知道 drv: the type of drive train, where f = front-wheel drive, r = rear wheel drive, 4 = 4wd 即传动系的类型，f表示前轮驱动，r表示后轮驱动，4表示四轮驱动。 使用hwy和cyl绘制一张散点图。 ggplot(data = mpg)+ geom_point(mapping = aes(x = hwy,y = cyl)) 啊，这奇怪的图形。 如果使用class和drv绘制散点图，会发生什么情况？为什么这张图没什么用处？ ggplot(data = mpg)+ geom_point(mapping = aes(x = class,y = drv)) 会出现很多点重合的现象，这是这张图没什么用处的原因吗？但是自我感觉还是保留了些许信息，但的确被压缩了很多。 3.3 Aesthetic mappings 我们在前面学习了如何把数据框属性映射为x,y轴，实际上还可以映射其他图形属性。 在引擎大小(displ)-燃油效率(hwy)散点图中增加多一个映射，将点的颜色映射为变量class ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = class)) 类似于点的颜色，还有的图形属性为： 点的透明度alpha 点的大小size，单位为毫米 点的形状shape，ggplot2只能同时使用6种形状 还可以通过?geom_point来查看 除了映射图形属性让ggplot2帮忙设置，还可以手动为几何对象设置图形属性。 ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy),colour = &#39;blue&#39;) 上图会将所有点都绘制成蓝色，因为我们并没有对点的颜色建立映射，而是直接设置。这与前面的图不同。 3.3.1 Exercises 以下这段代码有什么错误？为什么点不是蓝色的？ ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = &quot;blue&quot;) ) 这是因为这段代码把字符串常量当作数据框属性映射为点的颜色，由于各点的值都是常量“blue”故大家的颜色也一样，为默认的第一种颜色：红色。 事实上， ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = &quot;hello&quot;) ) 不论那个字符串是什么，甚至不是颜色的字符串也没有什么影响的。 (2)mpg中的哪些变量是分类变量？哪些变量是连续变量？（提示：输入?mpg来阅读这个数据集的文档。）当调用mpg时，如何才能看到这些信息？ 当然可以阅读文档，但也可以 str(mpg) #&gt; tibble [234 x 11] (S3: tbl_df/tbl/data.frame) #&gt; $ manufacturer: chr [1:234] &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... #&gt; $ model : chr [1:234] &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... #&gt; $ displ : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... #&gt; $ year : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... #&gt; $ cyl : int [1:234] 4 4 4 4 6 6 6 4 4 4 ... #&gt; $ trans : chr [1:234] &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... #&gt; $ drv : chr [1:234] &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... #&gt; $ cty : int [1:234] 18 21 20 21 16 18 18 18 16 20 ... #&gt; $ hwy : int [1:234] 29 29 31 30 26 26 27 26 25 28 ... #&gt; $ fl : chr [1:234] &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... #&gt; $ class : chr [1:234] &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... summary(mpg) #&gt; manufacturer model displ year #&gt; Length:234 Length:234 Min. :1.60 Min. :1999 #&gt; Class :character Class :character 1st Qu.:2.40 1st Qu.:1999 #&gt; Mode :character Mode :character Median :3.30 Median :2004 #&gt; Mean :3.47 Mean :2004 #&gt; 3rd Qu.:4.60 3rd Qu.:2008 #&gt; Max. :7.00 Max. :2008 #&gt; cyl trans drv cty #&gt; Min. :4.00 Length:234 Length:234 Min. : 9.0 #&gt; 1st Qu.:4.00 Class :character Class :character 1st Qu.:14.0 #&gt; Median :6.00 Mode :character Mode :character Median :17.0 #&gt; Mean :5.89 Mean :16.9 #&gt; 3rd Qu.:8.00 3rd Qu.:19.0 #&gt; Max. :8.00 Max. :35.0 #&gt; hwy fl class #&gt; Min. :12.0 Length:234 Length:234 #&gt; 1st Qu.:18.0 Class :character Class :character #&gt; Median :24.0 Mode :character Mode :character #&gt; Mean :23.4 #&gt; 3rd Qu.:27.0 #&gt; Max. :44.0 将一个连续变量映射为color、size和shape。对分类变量和连续变量来说，这些图形 属性的表现有什么不同？ 实践是检验真理的唯一标准，我们试试看： ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = cty) ) ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, size = cty) ) ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, shape = cty) ) 前两个还好，后面这个形状是直接报错无法映射了。毕竟color还有size都是可以渐变也即可以建立连续映射到连续的，但是形状就是铁定的离散值了，无法与连续值建立映射。 (4)如果将同一个变量映射为多个图形属性，会发生什么情况？ 试试看： ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, colour = class, size = class) ) #&gt; Warning: Using size for a discrete variable is not advised. 咦，会叠加的耶。 (5)stroke这个图形属性的作用是什么？它适用于哪些形状？（提示：使用?geom_point命令。） ?geom_point #&gt; starting httpd help server ... done 但是里面没有具体涉及。实践一下 ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, stroke = cty*0.2, size = cty) ) 查阅https://ggplot2.tidyverse.org/articles/ggplot2-specs.html#colour-and-fill-1， stroke这个图形属性是用于21-24形状的点的描边大小。 如果将图形属性映射为非变量名对象，比如aes(color = displ &lt; 5)，会发生什么情况？ ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy, color = displ &lt; 5) ) 嗯，还是可以映射成图形属性的。 3.4 Common problems 这样子是错的 ggplot(data = mpg) +geom_point(mapping = aes(x = displ, y = hwy, color = class)) 加号要放在代码的末尾。 3.5 Facets分面 一个参数的分面：利用函数facet_wrap()。例如： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ class, nrow = 2) 每一个“面”都是属性class的一个值，所以传递给facet_wrap()的变量应该是离散型的。参数nrow表示分面的行数。 两个参数的分面：利用函数facet_grid()。例如： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl) 每一个面都由(cyl,drv)决定。 ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) 想要取消在行的维度分面，用.替代属性。 3.5.1 Exercises 如果使用连续变量进行分面，会发生什么情况？ 看一个参数的： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ cty, nrow = 2) 可以看到它会把连续变量的所有取值都绘制分面了。 在使用facet_grid(drv ~ cyl)生成的图中，空白单元的意义是什么？它们和以下代码 生成的图有什么关系？ ggplot(data = mpg) + geom_point(mapping = aes(x = drv, y = cyl)) 而 ggplot(data = mpg) + facet_grid(drv ~ cyl) 这个图只是对变量drv,cyl绘制分面，而上图是对这两个变量绘制散点图。 以下代码会绘制出什么图？ . 的作用是什么？ ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(drv ~ .) ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_grid(. ~ cyl) 这两幅图实际上是按单个变量按列或行分面，与facet_warp()不同之处： ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + facet_wrap(~ cyl) facet_warp()对单个变量分面不会考虑按行或者按列。 查看本节的第一个分面图， 与使用图形属性相比，使用分面的优势和劣势分别是什么？如果有一个更大的数据集，你将如何权衡这两种方法的优劣？ 使用分面的优势：可以更好地看清，在固定某个变量（上图的class）时其余两个变量的关系。劣势就是三个变量的共同作用不太好看清了。 所以我觉得，当我们要考虑多个变量的共同作用、相互关系时可以考虑使用图形属性，当我们想要固定某个变量考虑其他变量时可以考虑分面。 阅读?facet_wrap的帮助页面。nrow和ncol的功能分别是什么？还有哪些选项可以控 制分面的布局？为什么函数facet_grid()没有变量nrow和ncol？ nrow和ncol的功能分别是控制分面图的行列个数。函数facet_grid()的行列数是依赖于分面变量的取值数，所以无法自定义。 在使用函数facet_grid()时，一般应该将具有更多唯一值的变量放在列上。为什么这么做呢？ 增加分面图的行数，从而每幅图看起来更好看、清晰，吧。 3.6 几何对象 几何对象是图中用来表示数据的几何图形对象，在ggplot2中使用几何对象函数来实现，比如 geom_point(),geom_smooth()等等，对于同一个数据对象，使用什么样的几何对象来展示，这估计也是一个大学问啊。 ggplot2中每个几何对象函数都有mapping参数，但并不意味着可以任意设置所有的图形属性，比如geom_point()就没有linetype属性。每个几何对象的详情可以使用帮助?geom_point。 3.6.1 分组绘图 使用单一几何对象实现分组绘图： 将一个图形属性映射为一个离散变量，自动添加图例（巨方便） ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, color = drv)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 使用group参数 ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy, group = drv)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 3.6.2 多个几何对象 想要在一幅图上显示多个几何对象，只需要把图层不断叠加。例如： ggplot(data = mpg) + geom_smooth(mapping = aes(x = displ, y = hwy))+ geom_point(mapping = aes(x = displ, y = hwy)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 可以看到，两个几何对象的映射是重复的，可以用全局映射替代。即 ggplot(data = mpg,mapping = aes(x = displ, y = hwy))+ geom_point()+ geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 这样修改全局映射就会对所有几何对象有影响。 关于全局映射与局部映射：全局映射会作用与所有几何对象，局部映射只会作用与当前几何对象，并且局部映射可以拓展（不冲突时）或者覆盖全局映射（冲突时）。对于全局指定数据集以及局部指定数据集也类似。例如， ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth( data = filter(mpg, class == &quot;subcompact&quot;), se = FALSE ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 上例中，全局指定数据集与局部指定数据集冲突，所以几何对象geom_smooth只绘制了局部指定的数据集。局部映射color = class与全局映射不冲突，所以几何对象geom_point被三个映射作用。 3.6.3 练习 在绘制折线图、箱线图、直方图和分区图时，应该分别使用哪种几何对象？ 参考： https://ggplot2.tidyverse.org/reference/index.html。 在脑海中运行以下代码，并预测会有何种输出。接着在R中运行代码，并检查你的预测是否正确。 预测：对数据中变量drv不同值分别绘制散点图并绘制该散点图的平滑拟合曲线。 实际： ggplot( data = mpg, mapping = aes(x = displ, y = hwy, color = drv) ) + geom_point() + geom_smooth(se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 嗯，一样的。 show.legend = FALSE的作用是什么？删除它会发生什么情况？你觉得我为什么要在本 章前面的示例中使用这句代码？ 作用是不显示图例，删除它就显示图例呗。为了体现将一个图形属性映射为一个离散变量时ggplot2可以自动添加图例。 geom_smooth()函数中的se参数的作用是什么？ ?geom_smooth 可以看到se参数的作用是控制是否展示拟合曲线的置信区间。 以下代码生成的两张图有什么区别吗？为什么？ ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot() + geom_point( data = mpg, mapping = aes(x = displ, y = hwy) ) + geom_smooth( data = mpg, mapping = aes(x = displ, y = hwy) ) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 一样的呀，不就是把全局变量放在局部变量那里吗… 自己编写R代码来生成以下各图。 ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth(se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth( mapping = aes(group=drv),se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy,color=drv)) + geom_point() + geom_smooth(se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color=drv)) + geom_smooth(se=F) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color=drv)) + geom_smooth(se=F,mapping = aes(linetype=drv)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color=drv)) 3.7 统计变换 很多图形绘制的是数据集的原始数据，比如散点图,它把原始数据中已有的变量映射到图形属性中。 另外一些图形则可以绘制那些计算出的新数据，比如条形图。例如， ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut)) y轴的count变量是原始数据中所没有的，是通过统计变换（stat）后得到的。所以对于这些函数，它们作用的过程可以分为两步，先是处理原始数据集，后是将处理后的数据集的变量映射到图形属性。但我们往往不需要关注底层统计变换的实现过程。 3.7.1 底层实现 当我们需要关注底层实现过程的时候，我们需要知道： 通过查看stat参数的默认值，可以知道几何对象函数使用了哪种统计变换函数。统计函数会计算出不止一个新变量，例如可以通过?geom_bar的Computed variables一节看到。 统计变换函数指的是实现某种统计变换的函数，例如count-&gt;stat_count()。 通常来说，几何对象函数和统计变换函数可以互换使用，如geom_bar与stat_count，因为每个几何对象函数都有一个默认统计变换，每个统计变换函数都有一个默认几何对象 3.7.2 显式使用 当我们想要显式使用某种统计变换时， 想要覆盖默认的统计变换：更改stat参数值，并指定各图形属性的映射。例 demo &lt;- tribble( ~a, ~b, &quot;bar_1&quot;, 20, &quot;bar_2&quot;, 30, &quot;bar_3&quot;, 40 ) ggplot(data = demo) + geom_bar( mapping = aes(x = a, y = b), stat = &quot;identity&quot; ) ggplot(data = demo) + geom_bar( mapping = aes(x = a) ) 其中，stat = \"identity\"表示不使用统计变换（即使用恒等变换）。 想要覆盖从统计变换生成的变量到图形属性的默认映射。 前面我们说过，统计函数会计算出不止一个新变量，我们可以显示地更改变量到图形属性的默认映射，例如，默认的： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut) ) stat_count计算的变量除了count（默认映射）还有prop，更改一下映射： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..prop.., group = 1) ) 可以看到y = ..prop..而不是y = prop估计是为了表明这个prop是统计变换计算出来的中间变量，而不是原始数据中的变量。验证一下： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, y = ..count.., group = 1) ) 可以得到默认的绘图。 想要在代码中强调统计变换。而非几何对象。如 ggplot(data = diamonds) + stat_summary( mapping = aes(x = cut, y = depth), fun.min = min, fun.max = max, fun = median ) 3.7.3 练习 stat_summary()函数的默认几何对象是什么？不使用统计变换函数的话，如何使用几何对象函数重新生成以上的图？ 可以看到geom = \"pointrange\"，从而默认的几何对象为geom_pointrange。利用pointrange生成图如下： ggplot(data = diamonds) + geom_pointrange( mapping = aes(x = cut, y = depth), stat = &quot;summary&quot;, fun.min = min, fun.max = max, fun = median ) 默认是不做统计变换，所以要显示指定一下参数stat。 geom_col()函数的功能是什么？它和geom_bar()函数有何不同？ geom_col()函数默认不使用统计变换，即需要把原始数据中某个变量映射到y轴上。geom_bar()函数默认使用统计变换。 多数几何对象和统计变换都是成对出现的，总是配合使用。仔细阅读文档，列出所有 成对的几何对象和统计变换。它们有什么共同之处？ 参考：https://ggplot2.tidyverse.org/reference/index.html 。名字大多类似？ stat_smooth()函数会计算出什么变量？哪些参数可以控制它的行为？ y：预测值，ymin,ymax：y均值的置信区间，se：标准误差。嗯…太多了… 在比例条形图中，我们需要设定group = 1，这是为什么呢？换句话说，以下两张图会 有什么问题？ ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop..)) ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = color, y = ..prop..) ) 你需要把所有数据放在一个组里面考虑，否则对于cut的每一个值分为一组，prop值都会是1。只需要把一个常量映射为group参数即可。 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, y = ..prop..,group=&quot;hello&quot;)) 3.8 位置调整 3.8.1 条形图上色 使用color或者fill图形属性 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, color = cut)) ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = cut)) 可以看到，color为边框上色，fill为图形填充颜色。 改变fill映射的变量，可以得到分块堆砌条形图。 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity)) 3.8.2 位置调整功能 这是由position参数设定的位置调整功能自动完成的，默认为stack（堆砌），还有其余值为identity,fill,dodge。 position = \"identity\"：将每个对象直接显示在图中，在图层上进行堆砌。这种方式不太适合条形图，因为条形会彼此重叠。为了让重叠部分能够显示出来，我们可以设置alpha参数为一个较小的数，从而使得条形略微透明；或者设定fill = NA，让条形完全透明： ggplot( data = diamonds, mapping = aes(x = cut, fill = clarity) ) + geom_bar(alpha = 1/5, position = &quot;identity&quot;) ggplot( data = diamonds, mapping = aes(x = cut, color = clarity) ) + geom_bar(fill = NA, position = &quot;identity&quot;) position = \"fill\"：与堆叠相似，但每组堆叠条形具有同样的高度，因此这种条形图可以非常轻松地比较各组间的比例： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = &quot;fill&quot; ) position = \"dodge\"将每组中的条形依次并列放置，这样可以非常轻松地比较每个条形 表示的具体数值： ggplot(data = diamonds) + geom_bar( mapping = aes(x = cut, fill = clarity), position = &quot;dodge&quot; ) position = \"jitter\"：虽然不适合条形图，但非常适合散点图。它为每个数据点添加一个很小的随机扰动，这样就可以将重叠的点分散开来。用损失精确性的方法提高图形的启发性，我觉得想法非常棒呀，毕竟图形化本身就是在用降低精确性来提高启发性。 ggplot(data = mpg) + geom_point( mapping = aes(x = displ, y = hwy), position = &quot;jitter&quot; ) 3.8.3 练习 (1)以下图形有什么问题？应该如何改善？ ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() 重叠点太多，加入随机扰动看看： ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_jitter() 效果要好一点。 (2)geom_jitter()使用哪些参数来控制抖动的程度？ width,height，但不太清楚作用机制… (3)对比 geom_jitter() 与 geom_count()。 geom_jitter()通过对数据点加随机扰动把重叠点分开，而 geom_count()对于重叠点，将重叠点计数映射到改区域点的大小。即 ggplot(mpg, aes(cty, hwy)) + geom_count() (4)geom_boxplot()函数的默认位置调整方式是什么？创建mpg数据集的可视化表示来演示一下。 默认位置调整方式是dodge2。 ggplot(mpg, aes(class, hwy))+ geom_boxplot() 3.9 坐标系 coord_flip()交换x轴，y轴； coord_quickmap()为地图设置合适的纵横比； coord_polar()采用极坐标； 3.9.1 练习 (1)使用coord_polar()函数将堆叠式条形图转换为饼图。 ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut, fill = clarity))+ coord_polar() (2)labs()函数的功能是什么？阅读一下文档。 修改标签。 (3)coord_quickmap()函数和 coord_map() 函数的区别是什么？ 参考：https://ggplot2.tidyverse.org/reference/coord_map.html (4)下图表明城市和公路燃油效率之间有什么关系？为什么coord_fixed()函数很重要？geom_abline() 函数的作用是什么？ ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() + coord_fixed() 正相关（线性）。可以使数据点（看起来）成斜率为1或-1，否则就是 ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + geom_point() + geom_abline() geom_abline() 函数的作用是绘制参考直线。 3.10 图形分层语法 模板语法： ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; 如果构建一个图形？ 1.需要有一个数据集&lt;DATA&gt; 2.（通过统计变换&lt;STAT&gt;）将其转换为想要显示的信息 3.选择一个几何对象&lt;GEOM_FUNCTION&gt;来表示转换后的数据中的每个观测值， 4.选择几何对象的图形属性来表示数据中的变量，这会将每个变量的值映射&lt;MAPPINGS&gt;为图形属性的水平。 5.选择放置几何对象的坐标系&lt;COORDINATE_FUNCTION&gt; 6.进一步调整几何对象在坐标系中的位置（位置调整&lt;POSITION&gt;），或者将图划分为多个子图（分面&lt;FACET_FUNCTION&gt;） 7.添加一个或多个附加图层进行拓展。 "],["workflow-basics.html", "4 Workflow: basics 4.1 代码基础 4.2 对象名称 4.3 函数调用 4.4 练习", " 4 Workflow: basics 4.1 代码基础 在RStudio中R代码块中使用Alt加减号键，可以打出&lt;-并且左右加上空格，贼方便呀。 4.2 对象名称 对象名称必须以字母开头，并且只能包含字母、数字、_ 和 .。如何命名一个对象看个人习惯吧，最好就是能具有描述性。 4.3 函数调用 无 4.4 练习 (1)为什么以下代码不能正常运行？ my_variable &lt;- 10 my_varıable 上下两个对象名称不同的… (2)修改以下每段 R 代码，使其可以正常运行。 library(tidyverse) ggplot(data = mpg) + # dota-&gt;data geom_point(mapping = aes(x = displ, y = hwy)) filter(mpg, cyl == 8) # fliter-&gt;filter,= -&gt; == filter(diamonds, carat &gt; 3) # diamond -&gt; diamonds (3)按 Alt+Shift+K 组合键会发生什么情况？如何使用菜单完成同样的操作？ 打开键盘快捷键帮助。菜单操作：Tools-&gt;Keyboard Shortcuts Help "],["data-transformation.html", "5 Data transformation 5.1 简介 5.2 使用filter()筛选行 5.3 使用arrange()排列行 5.4 使用select()选择列 5.5 使用mutate()添加新变量 5.6 使用summarize()进行分组摘要 5.7 分组新变量（和筛选器）", " 5 Data transformation 5.1 简介 原始数据总是不会让人满意，为了满足自己分析的需求，对数据进行转换不可避免。这一章我们要学习的是dplyr包，用于转换数据。 5.1.1 准备工作 载入tidyverse跟nycflights13包： library(nycflights13) library(tidyverse) 5.1.2 tibble变量类型 • int 表示整数型变量。 • dbl 表示双精度浮点数型变量，或称实数。 • chr 表示字符向量，或称字符串。 • dttm 表示日期时间（日期 + 时间）型变量。 • lgl 表示逻辑型变量，是一个仅包括 TRUE 和 FALSE 的向量。 • fctr 表示因子，R 用其来表示具有固定数目的值的分类变量。 • date 表示日期型变量 实际上就是英文缩写，比较好记。 5.1.3 dplyr基础 下面五个函数的工作方式是相同的： 第一个参数是一个数据框。 随后的参数使用变量名称（不带引号）描述了在数据框上进行的操作。 输出结果是一个新数据框。 这样的属性可以让我们在后面很方便地使用管道实现复杂的数据处理。 5.2 使用filter()筛选行 filter()的一般使用方法如下： filter(flights,month == 1, day == 1) #&gt; # A tibble: 842 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 836 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 第一个参数是数据框，后面的参数是筛选数据框行的表达式。 关于筛选数据框行的表达式，我们常常需要用到： 比较运算符，&gt;、&gt;=、&lt;、&lt;=、!=（不等于）和 ==（等于） 逻辑运算符，&amp;、|、！（而不是&amp;&amp;，||） 其他，像 %in%, between 5.2.1 练习 (1)找出满足以下条件的所有航班。 a.到达时间延误 2 小时或更多的航班。 filter(flights,arr_delay&gt;=2*60) #&gt; # A tibble: 10,200 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 811 630 101 1047 830 #&gt; 2 2013 1 1 848 1835 853 1001 1950 #&gt; 3 2013 1 1 957 733 144 1056 853 #&gt; 4 2013 1 1 1114 900 134 1447 1222 #&gt; 5 2013 1 1 1505 1310 115 1638 1431 #&gt; 6 2013 1 1 1525 1340 105 1831 1626 #&gt; # ... with 10,194 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; b.飞往休斯顿（IAH 机场或 HOU 机场）的航班。 filter(flights,dest %in% c(&quot;IAH&quot;,&quot;HOU&quot;)) #&gt; # A tibble: 9,313 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 623 627 -4 933 932 #&gt; 4 2013 1 1 728 732 -4 1041 1038 #&gt; 5 2013 1 1 739 739 0 1104 1038 #&gt; 6 2013 1 1 908 908 0 1228 1219 #&gt; # ... with 9,307 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; c.由联合航空（United）、美利坚航空（American）或三角洲航空（Delta）运营的航班。 filter(flights,carrier %in% c(&quot;UA&quot;,&quot;AA&quot;,&quot;DL&quot;)) #&gt; # A tibble: 139,504 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 554 600 -6 812 837 #&gt; 5 2013 1 1 554 558 -4 740 728 #&gt; 6 2013 1 1 558 600 -2 753 745 #&gt; # ... with 139,498 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; d.夏季（7 月、8 月和 9 月）出发的航班。 filter(flights,month %in% c(7,8,9)) #&gt; # A tibble: 86,326 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 7 1 1 2029 212 236 2359 #&gt; 2 2013 7 1 2 2359 3 344 344 #&gt; 3 2013 7 1 29 2245 104 151 1 #&gt; 4 2013 7 1 43 2130 193 322 14 #&gt; 5 2013 7 1 44 2150 174 300 100 #&gt; 6 2013 7 1 46 2051 235 304 2358 #&gt; # ... with 86,320 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; e.到达时间延误超过 2 小时，但出发时间没有延误的航班。 filter(flights,arr_delay&gt;=2*60,dep_delay&lt;=0) #&gt; # A tibble: 29 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 27 1419 1420 -1 1754 1550 #&gt; 2 2013 10 7 1350 1350 0 1736 1526 #&gt; 3 2013 10 7 1357 1359 -2 1858 1654 #&gt; 4 2013 10 16 657 700 -3 1258 1056 #&gt; 5 2013 11 1 658 700 -2 1329 1015 #&gt; 6 2013 3 18 1844 1847 -3 39 2219 #&gt; # ... with 23 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; f.延误至少 1 小时，但飞行过程弥补回 30 分钟的航班。 也就是，出发时间延误超1小时，但出发时间延误-到达时间延误&gt;=30min filter(flights,dep_delay&gt;=1*60,dep_delay-arr_delay&gt;=30) #&gt; # A tibble: 2,074 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 1716 1545 91 2140 2039 #&gt; 2 2013 1 1 2205 1720 285 46 2040 #&gt; 3 2013 1 1 2326 2130 116 131 18 #&gt; 4 2013 1 3 1503 1221 162 1803 1555 #&gt; 5 2013 1 3 1821 1530 171 2131 1910 #&gt; 6 2013 1 3 1839 1700 99 2056 1950 #&gt; # ... with 2,068 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; g.出发时间在午夜和早上 6 点之间（包括 0 点和 6 点）的航班。 filter(flights,dep_time&gt;=0&amp;dep_time&lt;=600) #&gt; # A tibble: 9,344 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 9,338 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (2)dplyr中对筛选有帮助的另一个函数是between()。它的作用是什么？你能使用这个函数来简化解决前面问题的代码吗？ 用于实现letf&lt;=x&lt;=right的表达式。上面的g也可以写成 filter(flights,between(dep_time,0,600)) #&gt; # A tibble: 9,344 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 9,338 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (3)dep_time 有缺失值的航班有多少？其他变量的缺失值情况如何？这样的行表示什么情况？ filter(flights,is.na(dep_time)) #&gt; # A tibble: 8,255 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 NA 1630 NA NA 1815 #&gt; 2 2013 1 1 NA 1935 NA NA 2240 #&gt; 3 2013 1 1 NA 1500 NA NA 1825 #&gt; 4 2013 1 1 NA 600 NA NA 901 #&gt; 5 2013 1 2 NA 1540 NA NA 1747 #&gt; 6 2013 1 2 NA 1620 NA NA 1746 #&gt; # ... with 8,249 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; dep_delay,arr_time,arr_delay同时缺失，表示航班取消。 (4)为什么 NA ^ 0 的值不是 NA ？为什么 NA | TRUE 的值不是 NA ？为什么 FALSE &amp; NA 的值不是 NA ？你能找出一般规律吗？（NA * 0 则是精妙的反例！） 个人觉得，因为NA表示缺失值，所有有可能取到可取的任意值。 对于NA^0，NA*0等数学运算，NA可以取任意数值，对于NA所取任意值，如果表达式的值都唯一，那么这个就是该表达式的值，若不唯一，则应为NA。由于对于任意数值，它的0次幂都为1（包括Inf、-Inf），所以NA^0==1，而由于Inf*0=NaN，当NA取1时NA*0==0，不唯一，故NA * 0=NA。 对于NA | TRUE，FALSE &amp; NA，NA可以取TRUE或者FALSE，无论取什么值，两个表达式的值都唯一（分别为TRUE，FALSE），故它们的值都不是NA。 5.3 使用arrange()排列行 工作方式： arrange(flights,year,month,day) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 1 517 515 2 830 819 #&gt; 2 2013 1 1 533 529 4 850 830 #&gt; 3 2013 1 1 542 540 2 923 850 #&gt; 4 2013 1 1 544 545 -1 1004 1022 #&gt; 5 2013 1 1 554 600 -6 812 837 #&gt; 6 2013 1 1 554 558 -4 740 728 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 将数据框flights的行按照year,month,day的值升序排序，返回新的数据框。 使用 desc() 可以按列进行降序排序： arrange(flights,desc(dep_delay)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 此外，缺失值总是排在最后。 5.3.1 练习 (1)如何使用 arrange() 将缺失值排在最前面？（提示：使用 is.na()。） df &lt;- tibble(x = c(5, 2, NA)) arrange(df,desc(is.na(df))) #&gt; # A tibble: 3 x 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 NA #&gt; 2 5 #&gt; 3 2 不知道这算不算一个好的办法。但是要改变非缺失值顺序的同时又把缺失值放在前面，就有点复杂了，需要arrange两次。 (2)对ﬂights排序以找出延误时间最长的航班。找出出发时间最早的航班。 arrange(flights,desc(arr_delay)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange(flights,dep_time) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 13 1 2249 72 108 2357 #&gt; 2 2013 1 31 1 2100 181 124 2225 #&gt; 3 2013 11 13 1 2359 2 442 440 #&gt; 4 2013 12 16 1 2359 2 447 437 #&gt; 5 2013 12 20 1 2359 2 430 440 #&gt; 6 2013 12 26 1 2359 2 437 440 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (3)对flights排序以找出速度最快的航班。 需要根据distance（距离）以及air_time（飞行时间）去计算速度，并排序： arrange(flights,desc(distance/air_time)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 5 25 1709 1700 9 1923 1937 #&gt; 2 2013 7 2 1558 1513 45 1745 1719 #&gt; 3 2013 5 13 2040 2025 15 2225 2226 #&gt; 4 2013 3 23 1914 1910 4 2045 2043 #&gt; 5 2013 1 12 1559 1600 -1 1849 1917 #&gt; 6 2013 11 17 650 655 -5 1059 1150 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; (4)哪个航班的飞行时间最长？哪个最短？ arrange(flights,air_time) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 16 1355 1315 40 1442 1411 #&gt; 2 2013 4 13 537 527 10 622 628 #&gt; 3 2013 12 6 922 851 31 1021 954 #&gt; 4 2013 2 3 2153 2129 24 2247 2224 #&gt; 5 2013 2 5 1303 1315 -12 1342 1411 #&gt; 6 2013 2 12 2123 2130 -7 2211 2225 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; arrange(flights,desc(air_time)) #&gt; # A tibble: 336,776 x 19 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 3 17 1337 1335 2 1937 1836 #&gt; 2 2013 2 6 853 900 -7 1542 1540 #&gt; 3 2013 3 15 1001 1000 1 1551 1530 #&gt; 4 2013 3 17 1006 1000 6 1607 1530 #&gt; 5 2013 3 16 1001 1000 1 1544 1530 #&gt; 6 2013 2 5 900 900 0 1555 1540 #&gt; # ... with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, #&gt; # carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, #&gt; # air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 5.4 使用select()选择列 使用方法： select(dataframe,other) other一般可以有： 多个变量名标量 变量名向量 辅助函数，用于匹配变量名，或者将变量移到数据框前面（everything()） 位于前面的变量名参数的优先级更高，如果跟后面的变量名参数冲突（相同）会覆盖它。（可以参考练习(2)）。 5.4.1 练习 (1)从flights数据集中选择dep_time、dep_delay、arr_time和arr_delay，通过头脑风暴找出尽可能多的方法。 select(flights,dep_time,dep_delay,arr_time,arr_delay) # 原始方法 select(flights,dep_time:arr_delay,-c(sched_dep_time,sched_arr_time)) # 向量方法 select(flights,dep_time:arr_delay,-starts_with(&quot;sched&quot;)) # 利用辅助函数匹配需要舍弃的变量名 select(flights,starts_with(&quot;dep&quot;),starts_with(&quot;arr&quot;)) # 直接匹配变量名 select(flights,matches(&quot;^(dep|arr)&quot;)) # 利用正则匹配 (2)如果在select()函数中多次计入一个变量名，那么会发生什么情况？ select(flights,dep_time,dep_time) #&gt; # A tibble: 336,776 x 1 #&gt; dep_time #&gt; &lt;int&gt; #&gt; 1 517 #&gt; 2 533 #&gt; 3 542 #&gt; 4 544 #&gt; 5 554 #&gt; 6 554 #&gt; # ... with 336,770 more rows 只会选取一列。这就解释了为什么： select(flights, time_hour, air_time, everything()) #&gt; # A tibble: 336,776 x 19 #&gt; time_hour air_time year month day dep_time sched_dep_time #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013-01-01 05:00:00 227 2013 1 1 517 515 #&gt; 2 2013-01-01 05:00:00 227 2013 1 1 533 529 #&gt; 3 2013-01-01 05:00:00 160 2013 1 1 542 540 #&gt; 4 2013-01-01 05:00:00 183 2013 1 1 544 545 #&gt; 5 2013-01-01 06:00:00 116 2013 1 1 554 600 #&gt; 6 2013-01-01 05:00:00 150 2013 1 1 554 558 #&gt; # ... with 336,770 more rows, and 12 more variables: dep_delay &lt;dbl&gt;, #&gt; # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;, #&gt; # hour &lt;dbl&gt;, minute &lt;dbl&gt; 会把变量移到前面。 (3)one_of()函数的作用是什么？为什么它结合以下向量使用时非常有用？ vars &lt;- c( &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;dep_delay&quot;, &quot;arr_delay&quot;, &quot;hello&quot; ) select(flights,one_of(vars)) #&gt; Warning: Unknown columns: `hello` #&gt; # A tibble: 336,776 x 5 #&gt; year month day dep_delay arr_delay #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2013 1 1 2 11 #&gt; 2 2013 1 1 4 20 #&gt; 3 2013 1 1 2 33 #&gt; 4 2013 1 1 -1 -18 #&gt; 5 2013 1 1 -6 -25 #&gt; 6 2013 1 1 -4 12 #&gt; # ... with 336,770 more rows 选取数据框中包含在vars中的变量。 (4)以下代码的运行结果是否出乎意料？选择辅助函数处理大小写的默认方式是什么？如何改变默认方式？ select(flights, contains(&quot;TIME&quot;)) #&gt; # A tibble: 336,776 x 6 #&gt; dep_time sched_dep_time arr_time sched_arr_time air_time time_hour #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dttm&gt; #&gt; 1 517 515 830 819 227 2013-01-01 05:00:00 #&gt; 2 533 529 850 830 227 2013-01-01 05:00:00 #&gt; 3 542 540 923 850 160 2013-01-01 05:00:00 #&gt; 4 544 545 1004 1022 183 2013-01-01 05:00:00 #&gt; 5 554 600 812 837 116 2013-01-01 06:00:00 #&gt; 6 554 558 740 728 150 2013-01-01 05:00:00 #&gt; # ... with 336,770 more rows 有点出乎意料…查阅文档可以知道，那几个匹配的函数都有参数ignore.case（忽略大小写），默认为TRUE，修改一下就行了。 select(flights, contains(&quot;TIME&quot;,ignore.case = F)) #&gt; # A tibble: 336,776 x 0 5.5 使用mutate()添加新变量 我们可以使用mutate()添加新变量，也就是新的列，它往往是原有列的函数。 mutate()总是将新列添加在数据集的最后 一旦创建，新列就可以立即使用。不用等到返回数据框再使用新列。 如果只想保留新变量，可以使用transmute()函数。使用mutate()函数会保留原数据框的所有列，新列加在后面。 5.5.1 常用创建函数 创建新变量的多种函数可供同mutate()一同使用。最重要的一点是，这种函数必须是向 量化的。这个不难理解，毕竟我们是输入原有列（向量）而得到新列（向量）。 主要有： 算术运算符：+、-、*、/、^ 模运算符：%/%（整除） 和 %%（求余） 对数函数：log()、log2() 和 log10() 偏移函数：lead()、lag() 累加和滚动聚合：cumsum()、cumprod()、commin() 和 cummax()，以及cummean() 逻辑比较：&lt;、&lt;=、&gt;、&gt;= 和 != 排秩：min_rank()、 row_number()、dense_rank()、percent_rank()、cume_dist()和 ntile() 5.5.2 练习 (1)虽然现在的dep_time和sched_dep_time变量方便阅读，但不适合计算，因为它们实际上并不是连续型数值。将它们转换成一种更方便的表示形式，即从午夜开始的分钟数。 transmute(flights, dep_min=(dep_time %/% 100)*60+(dep_time %% 100), sched_dep_min = (sched_dep_time %/% 100)*60+(sched_dep_time %% 100)) #&gt; # A tibble: 336,776 x 2 #&gt; dep_min sched_dep_min #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 317 315 #&gt; 2 333 329 #&gt; 3 342 340 #&gt; 4 344 345 #&gt; 5 354 360 #&gt; 6 354 358 #&gt; # ... with 336,770 more rows (2)比较 air_time 和arr_time–dep_time。你期望看到什么？实际又看到了什么？如何解决这个问题？ transmute(flights,air_time=air_time,t=arr_time-dep_time) #&gt; # A tibble: 336,776 x 2 #&gt; air_time t #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 227 313 #&gt; 2 227 317 #&gt; 3 160 381 #&gt; 4 183 460 #&gt; 5 116 258 #&gt; 6 150 186 #&gt; # ... with 336,770 more rows 因为arr_time,dep_time的格式都是HMM或者HHMM，air_time格式是分钟，所以前者直接相减是不会等于后者。一种方法把它们都转换成分钟。 flights%&gt;% transmute(air_time, arr_min = (arr_time %/% 100)*60+(arr_time %% 100), dep_min = (dep_time %/% 100)*60+(dep_time %% 100), t_min = arr_min-dep_min ) #&gt; # A tibble: 336,776 x 4 #&gt; air_time arr_min dep_min t_min #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 227 510 317 193 #&gt; 2 227 530 333 197 #&gt; 3 160 563 342 221 #&gt; 4 183 604 344 260 #&gt; 5 116 492 354 138 #&gt; 6 150 460 354 106 #&gt; # ... with 336,770 more rows 本以为air_time会与t_min相等，但是并不是…大于小于都有，这就很奇怪了，特别是air_time大于t_min这是啥意思… (4)使用排秩函数找出 10 个延误时间最长的航班。如何处理名次相同的情况？仔细阅读 min_rank() 的帮助文件。 flights%&gt;% mutate(rank=min_rank(desc(arr_delay)))%&gt;% filter(rank&lt;=10)%&gt;% arrange(rank) #&gt; # A tibble: 10 x 20 #&gt; year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 2013 1 9 641 900 1301 1242 1530 #&gt; 2 2013 6 15 1432 1935 1137 1607 2120 #&gt; 3 2013 1 10 1121 1635 1126 1239 1810 #&gt; 4 2013 9 20 1139 1845 1014 1457 2210 #&gt; 5 2013 7 22 845 1600 1005 1044 1815 #&gt; 6 2013 4 10 1100 1900 960 1342 2211 #&gt; # ... with 4 more rows, and 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, #&gt; # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, #&gt; # distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, rank &lt;int&gt; (5)1:3 + 1:10会返回什么？为什么？ 1:3+1:10 #&gt; Warning in 1:3 + 1:10: 长的对象长度不是短的对象长度的整倍数 #&gt; [1] 2 4 6 5 7 9 8 10 12 11 相当于这样，长度不一样的向量运算时，短向量会“广播”： c(1:3,1:3,1:3,1)+1:10 #&gt; [1] 2 4 6 5 7 9 8 10 12 11 (6)R提供了哪些三角函数？ 利用 ?Trig 可以得到。 5.6 使用summarize()进行分组摘要 not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) 5.6.1 使用管道组合多种操作 x %&gt;% f(y)会转换成f(x,y)，依此类推。 在RStudio中管道%&gt;%的默认快捷键是Ctrl+Shift+M 5.6.2 练习 (1)通过头脑风暴，至少找出5种方法来确定一组航班的典型延误特征。思考以下场景。 • 一架航班 50% 的时间会提前 15 分钟，50% 的时间会延误 15 分钟。 • 一架航班总是会延误 10 分钟。 • 一架航班 50% 的时间会提前 30 分钟，50% 的时间会延误 30 分钟。 • 一架航班 99% 的时间会准时，1% 的时间会延误 2 个小时。 哪一种更重要：到达延误还是出发延误？ 那当然是到达延误更重要。 (2)找出另外一种方法，这种方法要可以给出与 not_cancelled %&gt;% count(dest)和not_cancelled %&gt;% count(tailnum, wt = distance)同样的输出（不能使用 count()）。 not_cancelled %&gt;% count(dest) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 264 #&gt; 3 ALB 418 #&gt; 4 ANC 8 #&gt; 5 ATL 16837 #&gt; 6 AUS 2411 #&gt; # ... with 98 more rows not_cancelled %&gt;% group_by(dest) %&gt;% summarise(n=n()) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 264 #&gt; 3 ALB 418 #&gt; 4 ANC 8 #&gt; 5 ATL 16837 #&gt; 6 AUS 2411 #&gt; # ... with 98 more rows not_cancelled %&gt;% count(tailnum, wt = distance) #&gt; # A tibble: 4,037 x 2 #&gt; tailnum n #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 D942DN 3418 #&gt; 2 N0EGMQ 239143 #&gt; 3 N10156 109664 #&gt; 4 N102UW 25722 #&gt; 5 N103US 24619 #&gt; 6 N104UW 24616 #&gt; # ... with 4,031 more rows not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise(n=sum(distance)) #&gt; # A tibble: 4,037 x 2 #&gt; tailnum n #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 D942DN 3418 #&gt; 2 N0EGMQ 239143 #&gt; 3 N10156 109664 #&gt; 4 N102UW 25722 #&gt; 5 N103US 24619 #&gt; 6 N104UW 24616 #&gt; # ... with 4,031 more rows (3)我们对已取消航班的定义(is.na(dep_delay))|(is.na(arr_delay))稍有欠佳。为什么？哪一列才是最重要的？ 我觉得，dep_time（出发时间）最重要，出发时间缺失明确表示航班取消。 (4)查看每天取消的航班数量。其中存在模式吗？已取消航班的比例与平均延误时间有关 系吗？ flights %&gt;% group_by(year,month,day) %&gt;% summarise(scale = mean(is.na(dep_time)), delay = mean(arr_delay,na.rm = T)) %&gt;% filter(scale&lt;0.5) %&gt;% # 去除两个离群点 ggplot(mapping = aes(x=scale,y=delay)) + geom_point()+ geom_smooth() 可以看到，已取消航班的比例升高，平均延误时间先较快增加随之变缓。 (5)哪个航空公司的延误情况最严重？挑战：你能否分清这是由于糟糕的机场设备，还是航空公司的问题？为什么能？为什么不能？（提示：考虑一下 flights %&gt;% group_by(carrier, dest) %&gt;% summarize(n())。） 不太明白…占个坑先。 (6)计算每架飞机在第一次延误超过1小时前的飞行次数。 有比较麻烦的做法… (7)count()函数中的sort参数的作用是什么？何时应该使用这个参数？ 没设置之前是这样的： not_cancelled %&gt;% count(dest) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ABQ 254 #&gt; 2 ACK 264 #&gt; 3 ALB 418 #&gt; 4 ANC 8 #&gt; 5 ATL 16837 #&gt; 6 AUS 2411 #&gt; # ... with 98 more rows 设置之后： not_cancelled %&gt;% count(dest,sort = T) #&gt; # A tibble: 104 x 2 #&gt; dest n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 ATL 16837 #&gt; 2 ORD 16566 #&gt; 3 LAX 16026 #&gt; 4 BOS 15022 #&gt; 5 MCO 13967 #&gt; 6 CLT 13674 #&gt; # ... with 98 more rows 返回数据框的行会按照计数的大小进行降序排序。 5.7 分组新变量（和筛选器） "]]
